[
    {
        "id": "a9b8c7d6e5f4g3h2i1j0",
        "type": "tab",
        "label": "Branch Management API",
        "disabled": false,
        "info": ""
    },
    {
        "id": "56ad11acd7070bcf",
        "type": "tab",
        "label": "Player Management API",
        "disabled": false,
        "info": "選手情報を管理するためのAPIフロー"
    },
    {
        "id": "venue_flow",
        "type": "tab",
        "label": "Venue Management API",
        "disabled": false,
        "info": ""
    },
    {
        "id": "658402238263a0e3",
        "type": "tab",
        "label": "Category Management API",
        "disabled": false,
        "info": "カテゴリー情報を管理するためのAPIフロー"
    },
    {
        "id": "tournament_flow",
        "type": "tab",
        "label": "Tournament Management API",
        "disabled": false,
        "info": "大会情報を管理するためのAPIフロー"
    },
    {
        "id": "tournament_category_flow",
        "type": "tab",
        "label": "Tournament Category API",
        "disabled": false,
        "info": "大会とカテゴリーの紐付けを管理するためのAPIフロー"
    },
    {
        "id": "9d8a9a504f2add4b",
        "type": "tab",
        "label": "Tournament Participant API",
        "disabled": false,
        "info": "大会出場選手を管理するためのAPIフロー"
    },
    {
        "id": "new_flow_tab_id",
        "type": "tab",
        "label": "Tournament Bracket API",
        "disabled": false,
        "info": "Vue.jsからトーナメント組み合わせデータを保存および読み込むためのAPIフロー"
    },
    {
        "id": "456322a74f8670b8",
        "type": "tab",
        "label": "League Bracket API",
        "disabled": false,
        "info": "",
        "env": []
    },
    {
        "id": "e1cb6bc6b2821422",
        "type": "tab",
        "label": "Pentagon Bracket API",
        "disabled": false,
        "info": "",
        "env": []
    },
    {
        "id": "059d960ae3fa1ba9",
        "type": "tab",
        "label": "Match Scheduler API KAI",
        "disabled": false,
        "info": "",
        "env": []
    },
    {
        "id": "5b092667c9e68b9b",
        "type": "tab",
        "label": "Match Details and Record Flow (Standard Nodes)",
        "disabled": false,
        "info": "",
        "env": []
    },
    {
        "id": "aab57a20387da7cf",
        "type": "postgreSQLConfig",
        "name": "",
        "host": "database",
        "hostFieldType": "str",
        "port": 5432,
        "portFieldType": "num",
        "database": "KUDO10",
        "databaseFieldType": "str",
        "ssl": "false",
        "sslFieldType": "bool",
        "applicationName": "",
        "applicationNameType": "str",
        "max": 10,
        "maxFieldType": "num",
        "idle": 1000,
        "idleFieldType": "num",
        "connectionTimeout": 10000,
        "connectionTimeoutFieldType": "num",
        "user": "postgres",
        "userFieldType": "str",
        "password": "postgres",
        "passwordFieldType": "str"
    },
    {
        "id": "e0d9c8b7a6f5e4d3c2b1",
        "type": "http in",
        "z": "a9b8c7d6e5f4g3h2i1j0",
        "name": "GET /branches",
        "url": "/branches",
        "method": "get",
        "upload": false,
        "swaggerDoc": "",
        "x": 100,
        "y": 100,
        "wires": [
            [
                "f1e2d3c4b5a6f7e8d9c0"
            ]
        ]
    },
    {
        "id": "f1e2d3c4b5a6f7e8d9c0",
        "type": "postgresql",
        "z": "a9b8c7d6e5f4g3h2i1j0",
        "name": "Select All Branches",
        "query": "SELECT branch_id, branch_nm, branch_nm2, created FROM public.branch_m ORDER BY branch_id",
        "postgreSQLConfig": "aab57a20387da7cf",
        "split": false,
        "rowsPerMsg": "",
        "outputs": 1,
        "x": 300,
        "y": 100,
        "wires": [
            [
                "g2h3i4j5k6l7m8n9o0p1"
            ]
        ]
    },
    {
        "id": "g2h3i4j5k6l7m8n9o0p1",
        "type": "http response",
        "z": "a9b8c7d6e5f4g3h2i1j0",
        "name": "Send Response",
        "statusCode": "200",
        "headers": {
            "Content-Type": "application/json"
        },
        "x": 1020,
        "y": 60,
        "wires": []
    },
    {
        "id": "h3i4j5k6l7m8n9o0p1q2",
        "type": "http in",
        "z": "a9b8c7d6e5f4g3h2i1j0",
        "name": "POST /branches",
        "url": "/branches",
        "method": "post",
        "upload": false,
        "swaggerDoc": "",
        "x": 100,
        "y": 200,
        "wires": [
            [
                "i4j5k6l7m8n9o0p1q2r3"
            ]
        ]
    },
    {
        "id": "i4j5k6l7m8n9o0p1q2r3",
        "type": "function",
        "z": "a9b8c7d6e5f4g3h2i1j0",
        "name": "Prepare Insert Query",
        "func": "const { branch_id, branch_nm, branch_nm2 } = msg.payload;\nif (!branch_id || !branch_nm) {\n    node.warn(\"Missing required fields for insert.\");\n    msg.statusCode = 400;\n    msg.payload = { error: \"branch_id and branch_nm are required.\" };\n    return [null, msg];\n}\nmsg.query = `INSERT INTO public.branch_m (branch_id, branch_nm, branch_nm2) VALUES ('${branch_id}', '${branch_nm}', '${branch_nm2 || ''}')`;\nreturn [msg, null];",
        "outputs": 2,
        "timeout": "",
        "noerr": 0,
        "initialize": "",
        "finalize": "",
        "libs": [],
        "x": 320,
        "y": 200,
        "wires": [
            [
                "j5k6l7m8n9o0p1q2r3s4"
            ],
            [
                "g2h3i4j5k6l7m8n9o0p1"
            ]
        ]
    },
    {
        "id": "j5k6l7m8n9o0p1q2r3s4",
        "type": "postgresql",
        "z": "a9b8c7d6e5f4g3h2i1j0",
        "name": "Insert Branch",
        "query": "",
        "postgreSQLConfig": "aab57a20387da7cf",
        "split": false,
        "rowsPerMsg": "",
        "outputs": 1,
        "x": 570,
        "y": 200,
        "wires": [
            [
                "k6l7m8n9o0p1q2r3s4t5"
            ]
        ]
    },
    {
        "id": "k6l7m8n9o0p1q2r3s4t5",
        "type": "function",
        "z": "a9b8c7d6e5f4g3h2i1j0",
        "name": "Set Success Response",
        "func": "msg.statusCode = 201;\nmsg.payload = { message: \"Branch created successfully.\" };\nreturn msg;",
        "outputs": 1,
        "timeout": "",
        "noerr": 0,
        "initialize": "",
        "finalize": "",
        "libs": [],
        "x": 810,
        "y": 200,
        "wires": [
            [
                "g2h3i4j5k6l7m8n9o0p1"
            ]
        ]
    },
    {
        "id": "l7m8n9o0p1q2r3s4t5u6",
        "type": "http in",
        "z": "a9b8c7d6e5f4g3h2i1j0",
        "name": "PUT /branches/:branch_id",
        "url": "/branches/:branch_id",
        "method": "put",
        "upload": false,
        "swaggerDoc": "",
        "x": 130,
        "y": 300,
        "wires": [
            [
                "m8n9o0p1q2r3s4t5u6v7"
            ]
        ]
    },
    {
        "id": "m8n9o0p1q2r3s4t5u6v7",
        "type": "function",
        "z": "a9b8c7d6e5f4g3h2i1j0",
        "name": "Prepare Update Query",
        "func": "const { branch_id } = msg.req.params;\nconst { branch_nm, branch_nm2 } = msg.payload;\n\nif (!branch_nm && !branch_nm2) {\n    node.warn(\"No fields to update.\");\n    msg.statusCode = 400;\n    msg.payload = { error: \"No fields provided for update.\" };\n    return [null, msg];\n}\n\nlet updateFields = [];\nif (branch_nm !== undefined) updateFields.push(`branch_nm = '${branch_nm}'`);\nif (branch_nm2 !== undefined) updateFields.push(`branch_nm2 = '${branch_nm2}'`);\n\nif (updateFields.length === 0) {\n    node.warn(\"No valid fields to update.\");\n    msg.statusCode = 400;\n    msg.payload = { error: \"No valid fields provided for update.\" };\n    return [null, msg];\n}\n\nmsg.query = `UPDATE public.branch_m SET ${updateFields.join(', ')} WHERE branch_id = '${branch_id}'`;\nreturn [msg, null];",
        "outputs": 2,
        "timeout": "",
        "noerr": 0,
        "initialize": "",
        "finalize": "",
        "libs": [],
        "x": 360,
        "y": 300,
        "wires": [
            [
                "n9o0p1q2r3s4t5u6v7w8"
            ],
            [
                "g2h3i4j5k6l7m8n9o0p1"
            ]
        ]
    },
    {
        "id": "n9o0p1q2r3s4t5u6v7w8",
        "type": "postgresql",
        "z": "a9b8c7d6e5f4g3h2i1j0",
        "name": "Update Branch",
        "query": "",
        "postgreSQLConfig": "aab57a20387da7cf",
        "split": false,
        "rowsPerMsg": "",
        "outputs": 1,
        "x": 600,
        "y": 300,
        "wires": [
            [
                "o0p1q2r3s4t5u6v7w8x9"
            ]
        ]
    },
    {
        "id": "o0p1q2r3s4t5u6v7w8x9",
        "type": "function",
        "z": "a9b8c7d6e5f4g3h2i1j0",
        "name": "Set Update Response",
        "func": "if (msg.payload.rowCount === 0) {\n    msg.statusCode = 404;\n    msg.payload = { error: \"Branch not found.\" };\n} else {\n    msg.statusCode = 200;\n    msg.payload = { message: \"Branch updated successfully.\" };\n}\nreturn msg;",
        "outputs": 1,
        "timeout": "",
        "noerr": 0,
        "initialize": "",
        "finalize": "",
        "libs": [],
        "x": 800,
        "y": 300,
        "wires": [
            [
                "g2h3i4j5k6l7m8n9o0p1"
            ]
        ]
    },
    {
        "id": "p1q2r3s4t5u6v7w8x9y0",
        "type": "http in",
        "z": "a9b8c7d6e5f4g3h2i1j0",
        "name": "DELETE /branches/:branch_id",
        "url": "/branches/:branch_id",
        "method": "delete",
        "upload": false,
        "swaggerDoc": "",
        "x": 140,
        "y": 400,
        "wires": [
            [
                "q2r3s4t5u6v7w8x9y0z1"
            ]
        ]
    },
    {
        "id": "q2r3s4t5u6v7w8x9y0z1",
        "type": "function",
        "z": "a9b8c7d6e5f4g3h2i1j0",
        "name": "Prepare Delete Query",
        "func": "const { branch_id } = msg.req.params;\nif (!branch_id) {\n    node.warn(\"Missing branch_id for delete.\");\n    msg.statusCode = 400;\n    msg.payload = { error: \"branch_id is required.\" };\n    return [null, msg];\n}\nmsg.query = `DELETE FROM public.branch_m WHERE branch_id = '${branch_id}'`;\nreturn [msg, null];",
        "outputs": 2,
        "timeout": "",
        "noerr": 0,
        "initialize": "",
        "finalize": "",
        "libs": [],
        "x": 380,
        "y": 400,
        "wires": [
            [
                "r3s4t5u6v7w8x9y0z1a2"
            ],
            [
                "g2h3i4j5k6l7m8n9o0p1"
            ]
        ]
    },
    {
        "id": "r3s4t5u6v7w8x9y0z1a2",
        "type": "postgresql",
        "z": "a9b8c7d6e5f4g3h2i1j0",
        "name": "Delete Branch",
        "query": "",
        "postgreSQLConfig": "aab57a20387da7cf",
        "split": false,
        "rowsPerMsg": "",
        "outputs": 1,
        "x": 600,
        "y": 400,
        "wires": [
            [
                "s4t5u6v7w8x9y0z1a2b3"
            ]
        ]
    },
    {
        "id": "s4t5u6v7w8x9y0z1a2b3",
        "type": "function",
        "z": "a9b8c7d6e5f4g3h2i1j0",
        "name": "Set Delete Response",
        "func": "if (msg.payload.rowCount === 0) {\n    msg.statusCode = 404;\n    msg.payload = { error: \"Branch not found.\" };\n} else {\n    msg.statusCode = 204; // No Content for successful delete\n    msg.payload = {};\n}\nreturn msg;",
        "outputs": 1,
        "timeout": "",
        "noerr": 0,
        "initialize": "",
        "finalize": "",
        "libs": [],
        "x": 820,
        "y": 400,
        "wires": [
            [
                "g2h3i4j5k6l7m8n9o0p1"
            ]
        ]
    },
    {
        "id": "e2803475c66fbcb8",
        "type": "http in",
        "z": "56ad11acd7070bcf",
        "name": "GET /players",
        "url": "/players",
        "method": "get",
        "upload": false,
        "swaggerDoc": "",
        "x": 100,
        "y": 100,
        "wires": [
            [
                "63d33f351d3b58a4"
            ]
        ]
    },
    {
        "id": "63d33f351d3b58a4",
        "type": "function",
        "z": "56ad11acd7070bcf",
        "name": "Prepare Select All Query",
        "func": "const branchId = msg.req.query.branch_id;\nlet whereClause = '';\n\nif (branchId) {\n    whereClause = `WHERE pm.branch_id = '${branchId}'`;\n}\n\n// player_m (pm) と branch_m (bm) を結合して branch_nm を取得\nmsg.query = `\n    SELECT\n        pm.player_id,\n        pm.branch_id,\n        pm.familyname,\n        pm.firstname,\n        pm.familyname2,\n        pm.firstname2,\n        pm.sex,\n        pm.birthday,\n        pm.admissionday,\n        pm.xclass,\n        pm.height,\n        pm.weight,\n        pm.remarks,\n        pm.created,\n        bm.branch_nm  -- ★追加: 支部名を取得\n    FROM\n        public.player_m pm\n    JOIN\n        public.branch_m bm ON pm.branch_id = bm.branch_id\n    ${whereClause}\n    ORDER BY\n        pm.branch_id, pm.player_id;\n`;\nreturn msg;",
        "outputs": 1,
        "timeout": "",
        "noerr": 0,
        "initialize": "",
        "finalize": "",
        "libs": [],
        "x": 350,
        "y": 100,
        "wires": [
            [
                "d55fb177e9c68402"
            ]
        ]
    },
    {
        "id": "d55fb177e9c68402",
        "type": "postgresql",
        "z": "56ad11acd7070bcf",
        "name": "Select All Players",
        "query": "",
        "postgreSQLConfig": "aab57a20387da7cf",
        "split": false,
        "rowsPerMsg": "",
        "outputs": 1,
        "x": 600,
        "y": 100,
        "wires": [
            [
                "81d46e28402a2bbe"
            ]
        ]
    },
    {
        "id": "81d46e28402a2bbe",
        "type": "http response",
        "z": "56ad11acd7070bcf",
        "name": "Send Response",
        "statusCode": "200",
        "headers": {
            "Content-Type": "application/json"
        },
        "x": 1100,
        "y": 100,
        "wires": []
    },
    {
        "id": "331fc7a7badfbfe3",
        "type": "http in",
        "z": "56ad11acd7070bcf",
        "name": "POST /players",
        "url": "/players",
        "method": "post",
        "upload": false,
        "swaggerDoc": "",
        "x": 100,
        "y": 200,
        "wires": [
            [
                "57ae25605e099780"
            ]
        ]
    },
    {
        "id": "57ae25605e099780",
        "type": "function",
        "z": "56ad11acd7070bcf",
        "name": "Prepare Insert Query",
        "func": "// 文字列値をSQLクエリに安全に埋め込むためのヘルパー関数\n// null/undefinedの場合はNULL、空文字列の場合は''、それ以外は'値'として返す\nfunction formatSqlString(value) {\n    if (value === null || value === undefined) {\n        return 'NULL';\n    }\n    const strValue = String(value);\n    if (strValue === '') {\n        return \"''\";\n    }\n    // 文字列内のシングルクォートをエスケープ (二重にする)\n    const escapedValue = strValue.replace(/'/g, \"''\");\n    return `'${escapedValue}'`;\n}\n\nconst { player_id, branch_id, familyname, firstname, familyname2, firstname2, sex, birthday, admissionday, xclass, height, weight, remarks } = msg.payload;\n\nif (!player_id || !branch_id || !familyname || !firstname || !sex) {\n    node.warn(\"Missing required fields for insert.\");\n    msg.statusCode = 400;\n    msg.payload = { error: \"player_id, branch_id, familyname, firstname, sex are required.\" };\n    return [null, msg];\n}\n\n// 日付型はそのままフォーマット\nconst birthdayVal = birthday ? `'${birthday}'` : 'NULL';\nconst admissiondayVal = admissionday ? `'${admissionday}'` : 'NULL';\n\n// 数値型はnullでない限りそのまま、nullの場合はNULL\nconst heightVal = height !== null ? height : 'NULL';\nconst weightVal = weight !== null ? weight : 'NULL';\n\n// 各文字列フィールドをformatSqlString関数で処理\nconst familyname2Sql = formatSqlString(familyname2);\nconst firstname2Sql = formatSqlString(firstname2);\nconst xclassSql = formatSqlString(xclass);\nconst remarksSql = formatSqlString(remarks);\n\nmsg.query = `INSERT INTO public.player_m (\n    player_id, branch_id, familyname, firstname, \n    familyname2, firstname2, sex, birthday, admissionday, \n    xclass, height, weight, remarks\n) VALUES (\n    '${player_id}', '${branch_id}', '${familyname}', '${firstname}', \n    ${familyname2Sql}, ${firstname2Sql}, '${sex}', ${birthdayVal}, ${admissiondayVal}, \n    ${xclassSql}, ${heightVal}, ${weightVal}, ${remarksSql}\n)`;\n\nreturn [msg, null];",
        "outputs": 2,
        "timeout": "",
        "noerr": 0,
        "initialize": "",
        "finalize": "",
        "libs": [],
        "x": 350,
        "y": 200,
        "wires": [
            [
                "63d061efcc867023"
            ],
            [
                "81d46e28402a2bbe"
            ]
        ]
    },
    {
        "id": "63d061efcc867023",
        "type": "postgresql",
        "z": "56ad11acd7070bcf",
        "name": "Insert Player",
        "query": "",
        "postgreSQLConfig": "aab57a20387da7cf",
        "split": false,
        "rowsPerMsg": "",
        "outputs": 1,
        "x": 600,
        "y": 200,
        "wires": [
            [
                "0d3551e53a7faa97"
            ]
        ]
    },
    {
        "id": "0d3551e53a7faa97",
        "type": "function",
        "z": "56ad11acd7070bcf",
        "name": "Set Success Response",
        "func": "msg.statusCode = 201;\nmsg.payload = { message: \"Player created successfully.\" };\nreturn msg;",
        "outputs": 1,
        "timeout": "",
        "noerr": 0,
        "initialize": "",
        "finalize": "",
        "libs": [],
        "x": 850,
        "y": 200,
        "wires": [
            [
                "81d46e28402a2bbe"
            ]
        ]
    },
    {
        "id": "d40bdf870d348a0d",
        "type": "http in",
        "z": "56ad11acd7070bcf",
        "name": "PUT /players/:branch_id/:player_id",
        "url": "/players/:branch_id/:player_id",
        "method": "put",
        "upload": false,
        "swaggerDoc": "",
        "x": 100,
        "y": 300,
        "wires": [
            [
                "53d0952b26d41db3"
            ]
        ]
    },
    {
        "id": "53d0952b26d41db3",
        "type": "function",
        "z": "56ad11acd7070bcf",
        "name": "Prepare Update Query",
        "func": "// 文字列値をSQLクエリに安全に埋め込むためのヘルパー関数\n// null/undefinedの場合はNULL、空文字列の場合は''、それ以外は'値'として返す\nfunction formatSqlString(value) {\n    if (value === null || value === undefined) {\n        return 'NULL';\n    }\n    const strValue = String(value);\n    if (strValue === '') {\n        return \"''\";\n    }\n    // 文字列内のシングルクォートをエスケープ (二重にする)\n    const escapedValue = strValue.replace(/'/g, \"''\");\n    return `'${escapedValue}'`;\n}\n\nconst { branch_id, player_id } = msg.req.params;\nconst { familyname, firstname, familyname2, firstname2, sex, birthday, admissionday, xclass, height, weight, remarks } = msg.payload;\n\nlet updateFields = [];\n\n// 各フィールドをformatSqlString関数で処理し、updateFieldsに追加\nif (familyname !== undefined) updateFields.push(`familyname = ${formatSqlString(familyname)}`);\nif (firstname !== undefined) updateFields.push(`firstname = ${formatSqlString(firstname)}`);\n// familyname2, firstname2, xclass, remarks も同様に修正\nif (familyname2 !== undefined) updateFields.push(`familyname2 = ${formatSqlString(familyname2)}`);\nif (firstname2 !== undefined) updateFields.push(`firstname2 = ${formatSqlString(firstname2)}`);\nif (sex !== undefined) updateFields.push(`sex = ${formatSqlString(sex)}`);\nif (birthday !== undefined) updateFields.push(`birthday = ${birthday ? `'${birthday}'` : 'NULL'}`);\nif (admissionday !== undefined) updateFields.push(`admissionday = ${admissionday ? `'${admissionday}'` : 'NULL'}`);\nif (xclass !== undefined) updateFields.push(`xclass = ${formatSqlString(xclass)}`);\nif (height !== undefined) updateFields.push(`height = ${height !== null ? height : 'NULL'}`);\nif (weight !== undefined) updateFields.push(`weight = ${weight !== null ? weight : 'NULL'}`);\nif (remarks !== undefined) updateFields.push(`remarks = ${formatSqlString(remarks)}`);\n\nif (updateFields.length === 0) {\n    node.warn(\"No fields to update.\");\n    msg.statusCode = 400;\n    msg.payload = { error: \"No fields provided for update.\" };\n    return [null, msg];\n}\n\nmsg.query = `UPDATE public.player_m SET ${updateFields.join(', ')} WHERE branch_id = '${branch_id}' AND player_id = '${player_id}'`;\nreturn [msg, null];",
        "outputs": 2,
        "timeout": "",
        "noerr": 0,
        "initialize": "",
        "finalize": "",
        "libs": [],
        "x": 350,
        "y": 300,
        "wires": [
            [
                "70a0a7f01dfc2da2"
            ],
            [
                "81d46e28402a2bbe"
            ]
        ]
    },
    {
        "id": "70a0a7f01dfc2da2",
        "type": "postgresql",
        "z": "56ad11acd7070bcf",
        "name": "Update Player",
        "query": "",
        "postgreSQLConfig": "aab57a20387da7cf",
        "split": false,
        "rowsPerMsg": "",
        "outputs": 1,
        "x": 600,
        "y": 300,
        "wires": [
            [
                "0adab08ddea77366"
            ]
        ]
    },
    {
        "id": "0adab08ddea77366",
        "type": "function",
        "z": "56ad11acd7070bcf",
        "name": "Set Update Response",
        "func": "if (msg.payload.rowCount === 0) {\n    msg.statusCode = 404;\n    msg.payload = { error: \"Player not found.\" };\n} else {\n    msg.statusCode = 200;\n    msg.payload = { message: \"Player updated successfully.\" };\n}\nreturn msg;",
        "outputs": 1,
        "timeout": "",
        "noerr": 0,
        "initialize": "",
        "finalize": "",
        "libs": [],
        "x": 850,
        "y": 300,
        "wires": [
            [
                "81d46e28402a2bbe"
            ]
        ]
    },
    {
        "id": "3ada68c2910f84d2",
        "type": "http in",
        "z": "56ad11acd7070bcf",
        "name": "DELETE /players/:branch_id/:player_id",
        "url": "/players/:branch_id/:player_id",
        "method": "delete",
        "upload": false,
        "swaggerDoc": "",
        "x": 100,
        "y": 400,
        "wires": [
            [
                "f90c68c350efd733"
            ]
        ]
    },
    {
        "id": "f90c68c350efd733",
        "type": "function",
        "z": "56ad11acd7070bcf",
        "name": "Prepare Delete Query",
        "func": "const { branch_id, player_id } = msg.req.params;\nif (!branch_id || !player_id) {\n    node.warn(\"Missing branch_id or player_id for delete.\");\n    msg.statusCode = 400;\n    msg.payload = { error: \"branch_id and player_id are required.\" };\n    return [null, msg];\n}\nmsg.query = `DELETE FROM public.player_m WHERE branch_id = '${branch_id}' AND player_id = '${player_id}'`;\nreturn [msg, null];",
        "outputs": 2,
        "timeout": "",
        "noerr": 0,
        "initialize": "",
        "finalize": "",
        "libs": [],
        "x": 380,
        "y": 400,
        "wires": [
            [
                "34e898361833f42a"
            ],
            [
                "81d46e28402a2bbe"
            ]
        ]
    },
    {
        "id": "34e898361833f42a",
        "type": "postgresql",
        "z": "56ad11acd7070bcf",
        "name": "Delete Player",
        "query": "",
        "postgreSQLConfig": "aab57a20387da7cf",
        "split": false,
        "rowsPerMsg": "",
        "outputs": 1,
        "x": 600,
        "y": 400,
        "wires": [
            [
                "4f03ae53d2274799"
            ]
        ]
    },
    {
        "id": "4f03ae53d2274799",
        "type": "function",
        "z": "56ad11acd7070bcf",
        "name": "Set Delete Response",
        "func": "if (msg.payload.rowCount === 0) {\n    msg.statusCode = 404;\n    msg.payload = { error: \"Player not found.\" };\n} else {\n    msg.statusCode = 204; // No Content for successful delete\n    msg.payload = {};\n}\nreturn msg;",
        "outputs": 1,
        "timeout": "",
        "noerr": 0,
        "initialize": "",
        "finalize": "",
        "libs": [],
        "x": 850,
        "y": 400,
        "wires": [
            [
                "81d46e28402a2bbe"
            ]
        ]
    },
    {
        "id": "f4c565813aead6d3",
        "type": "http in",
        "z": "56ad11acd7070bcf",
        "name": "GET /branches",
        "url": "/branches",
        "method": "get",
        "upload": false,
        "swaggerDoc": "",
        "x": 100,
        "y": 500,
        "wires": [
            [
                "9b69a48615e218cd"
            ]
        ]
    },
    {
        "id": "9b69a48615e218cd",
        "type": "function",
        "z": "56ad11acd7070bcf",
        "name": "Prepare Select Branches Query",
        "func": "msg.query = `SELECT branch_id, branch_nm FROM public.branch_m ORDER BY branch_id`;\nreturn msg;",
        "outputs": 1,
        "timeout": "",
        "noerr": 0,
        "initialize": "",
        "finalize": "",
        "libs": [],
        "x": 350,
        "y": 500,
        "wires": [
            [
                "123f2beac5a86969"
            ]
        ]
    },
    {
        "id": "123f2beac5a86969",
        "type": "postgresql",
        "z": "56ad11acd7070bcf",
        "name": "Select Branches",
        "query": "",
        "postgreSQLConfig": "aab57a20387da7cf",
        "split": false,
        "rowsPerMsg": "",
        "outputs": 1,
        "x": 600,
        "y": 500,
        "wires": [
            [
                "81d46e28402a2bbe"
            ]
        ]
    },
    {
        "id": "v001",
        "type": "http in",
        "z": "venue_flow",
        "name": "GET /venues",
        "url": "/venues",
        "method": "get",
        "upload": false,
        "swaggerDoc": "",
        "x": 100,
        "y": 100,
        "wires": [
            [
                "v002"
            ]
        ]
    },
    {
        "id": "v002",
        "type": "function",
        "z": "venue_flow",
        "name": "Prepare Select All Query",
        "func": "msg.query = `SELECT venue_id, venue_nm, remarks, created FROM public.venue_m ORDER BY venue_id`;\nreturn msg;",
        "outputs": 1,
        "timeout": "",
        "noerr": 0,
        "initialize": "",
        "finalize": "",
        "libs": [],
        "x": 350,
        "y": 100,
        "wires": [
            [
                "v003"
            ]
        ]
    },
    {
        "id": "v003",
        "type": "postgresql",
        "z": "venue_flow",
        "name": "Select All Venues",
        "query": "",
        "postgreSQLConfig": "aab57a20387da7cf",
        "split": false,
        "rowsPerMsg": "",
        "outputs": 1,
        "x": 600,
        "y": 100,
        "wires": [
            [
                "v999"
            ]
        ]
    },
    {
        "id": "v004",
        "type": "http in",
        "z": "venue_flow",
        "name": "POST /venues",
        "url": "/venues",
        "method": "post",
        "upload": false,
        "swaggerDoc": "",
        "x": 100,
        "y": 200,
        "wires": [
            [
                "v005"
            ]
        ]
    },
    {
        "id": "v005",
        "type": "function",
        "z": "venue_flow",
        "name": "Prepare Insert Query",
        "func": "const { venue_id, venue_nm, remarks } = msg.payload;\nif (!venue_id || !venue_nm) {\n    node.warn(\"Missing required fields for insert.\");\n    msg.statusCode = 400;\n    msg.payload = { error: \"venue_id and venue_nm are required.\" };\n    return [null, msg];\n}\nmsg.query = `INSERT INTO public.venue_m (venue_id, venue_nm, remarks) VALUES ('${venue_id}', '${venue_nm}', '${remarks || ''}')`;\nreturn [msg, null];",
        "outputs": 2,
        "timeout": "",
        "noerr": 0,
        "initialize": "",
        "finalize": "",
        "libs": [],
        "x": 350,
        "y": 200,
        "wires": [
            [
                "v006"
            ],
            [
                "v999"
            ]
        ]
    },
    {
        "id": "v006",
        "type": "postgresql",
        "z": "venue_flow",
        "name": "Insert Venue",
        "query": "",
        "postgreSQLConfig": "aab57a20387da7cf",
        "split": false,
        "rowsPerMsg": "",
        "outputs": 1,
        "x": 600,
        "y": 200,
        "wires": [
            [
                "v007"
            ]
        ]
    },
    {
        "id": "v007",
        "type": "function",
        "z": "venue_flow",
        "name": "Set Success Response",
        "func": "msg.statusCode = 201;\nmsg.payload = { message: \"Venue created successfully.\" };\nreturn msg;",
        "outputs": 1,
        "timeout": "",
        "noerr": 0,
        "initialize": "",
        "finalize": "",
        "libs": [],
        "x": 850,
        "y": 200,
        "wires": [
            [
                "v999"
            ]
        ]
    },
    {
        "id": "v008",
        "type": "http in",
        "z": "venue_flow",
        "name": "PUT /venues/:venue_id",
        "url": "/venues/:venue_id",
        "method": "put",
        "upload": false,
        "swaggerDoc": "",
        "x": 100,
        "y": 300,
        "wires": [
            [
                "v009"
            ]
        ]
    },
    {
        "id": "v009",
        "type": "function",
        "z": "venue_flow",
        "name": "Prepare Update Query",
        "func": "const { venue_id } = msg.req.params;\nconst { venue_nm, remarks } = msg.payload;\n\nlet updateFields = [];\nif (venue_nm !== undefined) updateFields.push(`venue_nm = '${venue_nm}'`);\n// remarks が undefined でない、かつ null でない場合はクエリに含める\n// null を明示的に設定したい場合は remarks === null も含める\nif (remarks !== undefined) updateFields.push(`remarks = '${remarks || ''}'`);\n\nif (updateFields.length === 0) {\n    node.warn(\"No fields to update.\");\n    msg.statusCode = 400;\n    msg.payload = { error: \"No fields provided for update.\" };\n    return [null, msg];\n}\n\nmsg.query = `UPDATE public.venue_m SET ${updateFields.join(', ')} WHERE venue_id = '${venue_id}'`;\nreturn [msg, null];",
        "outputs": 2,
        "timeout": "",
        "noerr": 0,
        "initialize": "",
        "finalize": "",
        "libs": [],
        "x": 350,
        "y": 300,
        "wires": [
            [
                "v010"
            ],
            [
                "v999"
            ]
        ]
    },
    {
        "id": "v010",
        "type": "postgresql",
        "z": "venue_flow",
        "name": "Update Venue",
        "query": "",
        "postgreSQLConfig": "aab57a20387da7cf",
        "split": false,
        "rowsPerMsg": "",
        "outputs": 1,
        "x": 600,
        "y": 300,
        "wires": [
            [
                "v011"
            ]
        ]
    },
    {
        "id": "v011",
        "type": "function",
        "z": "venue_flow",
        "name": "Set Update Response",
        "func": "if (msg.payload.rowCount === 0) {\n    msg.statusCode = 404;\n    msg.payload = { error: \"Venue not found.\" };\n} else {\n    msg.statusCode = 200;\n    msg.payload = { message: \"Venue updated successfully.\" };\n}\nreturn msg;",
        "outputs": 1,
        "timeout": "",
        "noerr": 0,
        "initialize": "",
        "finalize": "",
        "libs": [],
        "x": 850,
        "y": 300,
        "wires": [
            [
                "v999"
            ]
        ]
    },
    {
        "id": "v012",
        "type": "http in",
        "z": "venue_flow",
        "name": "DELETE /venues/:venue_id",
        "url": "/venues/:venue_id",
        "method": "delete",
        "upload": false,
        "swaggerDoc": "",
        "x": 100,
        "y": 400,
        "wires": [
            [
                "v013"
            ]
        ]
    },
    {
        "id": "v013",
        "type": "function",
        "z": "venue_flow",
        "name": "Prepare Delete Query",
        "func": "const { venue_id } = msg.req.params;\nif (!venue_id) {\n    node.warn(\"Missing venue_id for delete.\");\n    msg.statusCode = 400;\n    msg.payload = { error: \"venue_id is required.\" };\n    return [null, msg];\n}\nmsg.query = `DELETE FROM public.venue_m WHERE venue_id = '${venue_id}'`;\nreturn [msg, null];",
        "outputs": 2,
        "timeout": "",
        "noerr": 0,
        "initialize": "",
        "finalize": "",
        "libs": [],
        "x": 350,
        "y": 400,
        "wires": [
            [
                "v014"
            ],
            [
                "v999"
            ]
        ]
    },
    {
        "id": "v014",
        "type": "postgresql",
        "z": "venue_flow",
        "name": "Delete Venue",
        "query": "",
        "postgreSQLConfig": "aab57a20387da7cf",
        "split": false,
        "rowsPerMsg": "",
        "outputs": 1,
        "x": 600,
        "y": 400,
        "wires": [
            [
                "v015"
            ]
        ]
    },
    {
        "id": "v015",
        "type": "function",
        "z": "venue_flow",
        "name": "Set Delete Response",
        "func": "if (msg.payload.rowCount === 0) {\n    msg.statusCode = 404;\n    msg.payload = { error: \"Venue not found.\" };\n} else {\n    msg.statusCode = 204; // No Content for successful delete\n    msg.payload = {};\n}\nreturn msg;",
        "outputs": 1,
        "timeout": "",
        "noerr": 0,
        "initialize": "",
        "finalize": "",
        "libs": [],
        "x": 850,
        "y": 400,
        "wires": [
            [
                "v999"
            ]
        ]
    },
    {
        "id": "v999",
        "type": "http response",
        "z": "venue_flow",
        "name": "Send Response",
        "statusCode": "200",
        "headers": {
            "Content-Type": "application/json"
        },
        "x": 1100,
        "y": 100,
        "wires": []
    },
    {
        "id": "912121e4d2ef713d",
        "type": "http in",
        "z": "658402238263a0e3",
        "name": "GET /categories",
        "url": "/categories",
        "method": "get",
        "upload": false,
        "swaggerDoc": "",
        "x": 100,
        "y": 100,
        "wires": [
            [
                "7aa582ba6e239f0c"
            ]
        ]
    },
    {
        "id": "7aa582ba6e239f0c",
        "type": "function",
        "z": "658402238263a0e3",
        "name": "Prepare Select All Query",
        "func": "msg.query = `SELECT category_id, category_nm, age_min, age_max, physical_index_min, physical_index_max, sex_rule, remarks, created FROM public.category_m ORDER BY category_id`;\nreturn msg;",
        "outputs": 1,
        "timeout": "",
        "noerr": 0,
        "initialize": "",
        "finalize": "",
        "libs": [],
        "x": 350,
        "y": 100,
        "wires": [
            [
                "a2c9d60a71f92ac5"
            ]
        ]
    },
    {
        "id": "a2c9d60a71f92ac5",
        "type": "postgresql",
        "z": "658402238263a0e3",
        "name": "Select All Categories",
        "query": "",
        "postgreSQLConfig": "aab57a20387da7cf",
        "split": false,
        "rowsPerMsg": "",
        "outputs": 1,
        "x": 600,
        "y": 100,
        "wires": [
            [
                "6c2561d7a09553cf"
            ]
        ]
    },
    {
        "id": "cf9477a549db2601",
        "type": "http in",
        "z": "658402238263a0e3",
        "name": "POST /categories",
        "url": "/categories",
        "method": "post",
        "upload": false,
        "swaggerDoc": "",
        "x": 100,
        "y": 200,
        "wires": [
            [
                "c9632c9daa369758"
            ]
        ]
    },
    {
        "id": "c9632c9daa369758",
        "type": "function",
        "z": "658402238263a0e3",
        "name": "Prepare Insert Query",
        "func": "// 文字列値をSQLクエリに安全に埋め込むためのヘルパー関数\nfunction formatSqlString(value) {\n    if (value === null || value === undefined) {\n        return 'NULL';\n    }\n    const strValue = String(value);\n    if (strValue === '') {\n        return \"''\";\n    }\n    const escapedValue = strValue.replace(/'/g, \"''\");\n    return `'${escapedValue}'`;\n}\n\nconst { category_id, category_nm, age_min, age_max, physical_index_min, physical_index_max, sex_rule, remarks } = msg.payload;\n\nif (!category_id || !category_nm || !sex_rule) {\n    node.warn(\"Missing required fields for insert.\");\n    msg.statusCode = 400;\n    msg.payload = { error: \"category_id, category_nm, sex_rule are required.\" };\n    return [null, msg];\n}\n\nconst ageMinVal = age_min !== null ? age_min : 'NULL';\nconst ageMaxVal = age_max !== null ? age_max : 'NULL';\nconst physicalIndexMinVal = physical_index_min !== null ? physical_index_min : 'NULL';\nconst physicalIndexMaxVal = physical_index_max !== null ? physical_index_max : 'NULL';\n\nmsg.query = `INSERT INTO public.category_m (\n    category_id, category_nm, age_min, age_max, \n    physical_index_min, physical_index_max, sex_rule, remarks\n) VALUES (\n    '${category_id}', ${formatSqlString(category_nm)}, ${ageMinVal}, ${ageMaxVal}, \n    ${physicalIndexMinVal}, ${physicalIndexMaxVal}, ${formatSqlString(sex_rule)}, ${formatSqlString(remarks)}\n)`;\n\nreturn [msg, null];",
        "outputs": 2,
        "timeout": "",
        "noerr": 0,
        "initialize": "",
        "finalize": "",
        "libs": [],
        "x": 350,
        "y": 200,
        "wires": [
            [
                "39ead171ef515368"
            ],
            [
                "6c2561d7a09553cf"
            ]
        ]
    },
    {
        "id": "39ead171ef515368",
        "type": "postgresql",
        "z": "658402238263a0e3",
        "name": "Insert Category",
        "query": "",
        "postgreSQLConfig": "aab57a20387da7cf",
        "split": false,
        "rowsPerMsg": "",
        "outputs": 1,
        "x": 600,
        "y": 200,
        "wires": [
            [
                "ff03f5a07d128b0d"
            ]
        ]
    },
    {
        "id": "ff03f5a07d128b0d",
        "type": "function",
        "z": "658402238263a0e3",
        "name": "Set Success Response",
        "func": "msg.statusCode = 201;\nmsg.payload = { message: \"Category created successfully.\" };\nreturn msg;",
        "outputs": 1,
        "timeout": "",
        "noerr": 0,
        "initialize": "",
        "finalize": "",
        "libs": [],
        "x": 850,
        "y": 200,
        "wires": [
            [
                "6c2561d7a09553cf"
            ]
        ]
    },
    {
        "id": "32bf65b8666e554a",
        "type": "http in",
        "z": "658402238263a0e3",
        "name": "PUT /categories/:category_id",
        "url": "/categories/:category_id",
        "method": "put",
        "upload": false,
        "swaggerDoc": "",
        "x": 100,
        "y": 300,
        "wires": [
            [
                "fae33dc45135590f"
            ]
        ]
    },
    {
        "id": "fae33dc45135590f",
        "type": "function",
        "z": "658402238263a0e3",
        "name": "Prepare Update Query",
        "func": "// 文字列値をSQLクエリに安全に埋め込むためのヘルパー関数\nfunction formatSqlString(value) {\n    if (value === null || value === undefined) {\n        return 'NULL';\n    }\n    const strValue = String(value);\n    if (strValue === '') {\n        return \"''\";\n    }\n    const escapedValue = strValue.replace(/'/g, \"''\");\n    return `'${escapedValue}'`;\n}\n\nconst categoryId = msg.req.params.category_id;\nconst { category_nm, age_min, age_max, physical_index_min, physical_index_max, sex_rule, remarks } = msg.payload;\n\nlet updateFields = [];\n\nif (category_nm !== undefined) updateFields.push(`category_nm = ${formatSqlString(category_nm)}`);\nif (age_min !== undefined) updateFields.push(`age_min = ${age_min !== null ? age_min : 'NULL'}`);\nif (age_max !== undefined) updateFields.push(`age_max = ${age_max !== null ? age_max : 'NULL'}`);\nif (physical_index_min !== undefined) updateFields.push(`physical_index_min = ${physical_index_min !== null ? physical_index_min : 'NULL'}`);\nif (physical_index_max !== undefined) updateFields.push(`physical_index_max = ${physical_index_max !== null ? physical_index_max : 'NULL'}`);\nif (sex_rule !== undefined) updateFields.push(`sex_rule = ${formatSqlString(sex_rule)}`);\nif (remarks !== undefined) updateFields.push(`remarks = ${formatSqlString(remarks)}`);\n\nif (updateFields.length === 0) {\n    node.warn(\"No fields to update.\");\n    msg.statusCode = 400;\n    msg.payload = { error: \"No fields provided for update.\" };\n    return [null, msg];\n}\n\nmsg.query = `UPDATE public.category_m SET ${updateFields.join(', ')} WHERE category_id = '${categoryId}'`;\nreturn [msg, null];",
        "outputs": 2,
        "timeout": "",
        "noerr": 0,
        "initialize": "",
        "finalize": "",
        "libs": [],
        "x": 350,
        "y": 300,
        "wires": [
            [
                "3ab3decd86f4243b"
            ],
            [
                "6c2561d7a09553cf"
            ]
        ]
    },
    {
        "id": "3ab3decd86f4243b",
        "type": "postgresql",
        "z": "658402238263a0e3",
        "name": "Update Category",
        "query": "",
        "postgreSQLConfig": "aab57a20387da7cf",
        "split": false,
        "rowsPerMsg": "",
        "outputs": 1,
        "x": 600,
        "y": 300,
        "wires": [
            [
                "523a7eda51dcf957"
            ]
        ]
    },
    {
        "id": "523a7eda51dcf957",
        "type": "function",
        "z": "658402238263a0e3",
        "name": "Set Update Response",
        "func": "if (msg.payload.rowCount === 0) {\n    msg.statusCode = 404;\n    msg.payload = { error: \"Category not found.\" };\n} else {\n    msg.statusCode = 200;\n    msg.payload = { message: \"Category updated successfully.\" };\n}\nreturn msg;",
        "outputs": 1,
        "timeout": "",
        "noerr": 0,
        "initialize": "",
        "finalize": "",
        "libs": [],
        "x": 850,
        "y": 300,
        "wires": [
            [
                "6c2561d7a09553cf"
            ]
        ]
    },
    {
        "id": "7243345b4429d56d",
        "type": "http in",
        "z": "658402238263a0e3",
        "name": "DELETE /categories/:category_id",
        "url": "/categories/:category_id",
        "method": "delete",
        "upload": false,
        "swaggerDoc": "",
        "x": 100,
        "y": 400,
        "wires": [
            [
                "85c65ba34487fa7b"
            ]
        ]
    },
    {
        "id": "85c65ba34487fa7b",
        "type": "function",
        "z": "658402238263a0e3",
        "name": "Prepare Delete Query",
        "func": "const categoryId = msg.req.params.category_id;\nif (!categoryId) {\n    node.warn(\"Missing category_id for delete.\");\n    msg.statusCode = 400;\n    msg.payload = { error: \"category_id is required.\" };\n    return [null, msg];\n}\nmsg.query = `DELETE FROM public.category_m WHERE category_id = '${categoryId}'`;\nreturn [msg, null];",
        "outputs": 2,
        "timeout": "",
        "noerr": 0,
        "initialize": "",
        "finalize": "",
        "libs": [],
        "x": 350,
        "y": 400,
        "wires": [
            [
                "203d98dad98c65fb"
            ],
            [
                "6c2561d7a09553cf"
            ]
        ]
    },
    {
        "id": "203d98dad98c65fb",
        "type": "postgresql",
        "z": "658402238263a0e3",
        "name": "Delete Category",
        "query": "",
        "postgreSQLConfig": "aab57a20387da7cf",
        "split": false,
        "rowsPerMsg": "",
        "outputs": 1,
        "x": 600,
        "y": 400,
        "wires": [
            [
                "134b73786eaefdde"
            ]
        ]
    },
    {
        "id": "134b73786eaefdde",
        "type": "function",
        "z": "658402238263a0e3",
        "name": "Set Delete Response",
        "func": "if (msg.payload.rowCount === 0) {\n    msg.statusCode = 404;\n    msg.payload = { error: \"Category not found.\" };\n} else {\n    msg.statusCode = 204; // No Content for successful delete\n    msg.payload = {};\n}\nreturn msg;",
        "outputs": 1,
        "timeout": "",
        "noerr": 0,
        "initialize": "",
        "finalize": "",
        "libs": [],
        "x": 850,
        "y": 400,
        "wires": [
            [
                "6c2561d7a09553cf"
            ]
        ]
    },
    {
        "id": "a21ff3eea443ba2e",
        "type": "http in",
        "z": "658402238263a0e3",
        "name": "GET /categories/:category_id",
        "url": "/categories/:category_id",
        "method": "get",
        "upload": false,
        "swaggerDoc": "",
        "x": 100,
        "y": 500,
        "wires": [
            [
                "54d4dd6fdec115c8"
            ]
        ]
    },
    {
        "id": "54d4dd6fdec115c8",
        "type": "function",
        "z": "658402238263a0e3",
        "name": "Prepare Select By ID Query",
        "func": "const categoryId = msg.req.params.category_id;\nif (!categoryId) {\n    msg.statusCode = 400;\n    msg.payload = { error: \"Category ID is required.\" };\n    return [null, msg];\n}\nmsg.query = `SELECT category_id, category_nm, age_min, age_max, physical_index_min, physical_index_max, sex_rule, remarks, created FROM public.category_m WHERE category_id = '${categoryId}'`;\nreturn [msg, null];",
        "outputs": 2,
        "timeout": "",
        "noerr": 0,
        "initialize": "",
        "finalize": "",
        "libs": [],
        "x": 350,
        "y": 500,
        "wires": [
            [
                "ff67f504a0a4f7bd"
            ],
            [
                "6c2561d7a09553cf"
            ]
        ]
    },
    {
        "id": "ff67f504a0a4f7bd",
        "type": "postgresql",
        "z": "658402238263a0e3",
        "name": "Select Category By ID",
        "query": "",
        "postgreSQLConfig": "aab57a20387da7cf",
        "split": false,
        "rowsPerMsg": "",
        "outputs": 1,
        "x": 600,
        "y": 500,
        "wires": [
            [
                "6540940189c9e024"
            ]
        ]
    },
    {
        "id": "6540940189c9e024",
        "type": "function",
        "z": "658402238263a0e3",
        "name": "Set Response",
        "func": "if (msg.payload.length === 0) {\n    msg.statusCode = 404;\n    msg.payload = { error: \"Category not found.\" };\n} else {\n    msg.statusCode = 200;\n    msg.payload = msg.payload[0];\n}\nreturn msg;",
        "outputs": 1,
        "timeout": "",
        "noerr": 0,
        "initialize": "",
        "finalize": "",
        "libs": [],
        "x": 850,
        "y": 500,
        "wires": [
            [
                "6c2561d7a09553cf"
            ]
        ]
    },
    {
        "id": "6c2561d7a09553cf",
        "type": "http response",
        "z": "658402238263a0e3",
        "name": "Send Response",
        "statusCode": "200",
        "headers": {
            "Content-Type": "application/json"
        },
        "x": 1100,
        "y": 100,
        "wires": []
    },
    {
        "id": "t001",
        "type": "http in",
        "z": "tournament_flow",
        "name": "GET /tournaments",
        "url": "/tournaments",
        "method": "get",
        "upload": false,
        "swaggerDoc": "",
        "x": 90,
        "y": 100,
        "wires": [
            [
                "t002"
            ]
        ]
    },
    {
        "id": "t002",
        "type": "function",
        "z": "tournament_flow",
        "name": "Prepare Select All Query (Dynamic Sort)",
        "func": "const sortBy = msg.req.query.sort || 'start_date'; // デフォルトは開催日\nconst orderBy = msg.req.query.order || 'DESC'; // デフォルトは降順\n\n// SQLインジェクション対策のための許可されたカラムリスト\nconst allowedSortBy = ['tournament_id', 'tournament_nm', 'start_date', 'end_date', 'created'];\nconst finalSortBy = allowedSortBy.includes(sortBy) ? sortBy : 'start_date';\n\n// 順序のバリデーション\nconst finalOrderBy = (orderBy.toUpperCase() === 'ASC' || orderBy.toUpperCase() === 'DESC') ? orderBy.toUpperCase() : 'DESC';\n\nmsg.query = `SELECT tournament_id, tournament_nm, start_date, end_date, venue_id, number_coat, remarks, created FROM public.tournament_m ORDER BY ${finalSortBy} ${finalOrderBy}`;\nreturn msg;",
        "outputs": 1,
        "timeout": "",
        "noerr": 0,
        "initialize": "",
        "finalize": "",
        "libs": [],
        "x": 360,
        "y": 100,
        "wires": [
            [
                "t003"
            ]
        ]
    },
    {
        "id": "t003",
        "type": "postgresql",
        "z": "tournament_flow",
        "name": "Select All Tournaments",
        "query": "",
        "postgreSQLConfig": "aab57a20387da7cf",
        "split": false,
        "rowsPerMsg": "",
        "outputs": 1,
        "x": 640,
        "y": 100,
        "wires": [
            [
                "t999"
            ]
        ]
    },
    {
        "id": "t004",
        "type": "http in",
        "z": "tournament_flow",
        "name": "GET /tournaments/:tournament_id",
        "url": "/tournaments/:tournament_id",
        "method": "get",
        "upload": false,
        "swaggerDoc": "",
        "x": 140,
        "y": 200,
        "wires": [
            [
                "t005"
            ]
        ]
    },
    {
        "id": "t005",
        "type": "function",
        "z": "tournament_flow",
        "name": "Prepare Select By ID Query",
        "func": "const tournamentId = msg.req.params.tournament_id;\nif (!tournamentId) {\n    msg.statusCode = 400;\n    msg.payload = { error: \"Tournament ID is required.\" };\n    return [null, msg];\n}\nmsg.query = `SELECT tournament_id, tournament_nm, start_date, end_date, venue_id, number_coat, remarks, created FROM public.tournament_m WHERE tournament_id = '${tournamentId}'`;\nreturn [msg, null];",
        "outputs": 2,
        "timeout": "",
        "noerr": 0,
        "initialize": "",
        "finalize": "",
        "libs": [],
        "x": 420,
        "y": 200,
        "wires": [
            [
                "t006"
            ],
            [
                "t999"
            ]
        ]
    },
    {
        "id": "t006",
        "type": "postgresql",
        "z": "tournament_flow",
        "name": "Select Tournament By ID",
        "query": "",
        "postgreSQLConfig": "aab57a20387da7cf",
        "split": false,
        "rowsPerMsg": "",
        "outputs": 1,
        "x": 690,
        "y": 200,
        "wires": [
            [
                "t007"
            ]
        ]
    },
    {
        "id": "t007",
        "type": "function",
        "z": "tournament_flow",
        "name": "Set Response",
        "func": "if (msg.payload.length === 0) {\n    msg.statusCode = 404;\n    msg.payload = { error: \"Tournament not found.\" };\n} else {\n    msg.statusCode = 200;\n    msg.payload = msg.payload[0];\n}\nreturn msg;",
        "outputs": 1,
        "timeout": "",
        "noerr": 0,
        "initialize": "",
        "finalize": "",
        "libs": [],
        "x": 900,
        "y": 200,
        "wires": [
            [
                "t999"
            ]
        ]
    },
    {
        "id": "t008",
        "type": "http in",
        "z": "tournament_flow",
        "name": "POST /tournaments",
        "url": "/tournaments",
        "method": "post",
        "upload": false,
        "swaggerDoc": "",
        "x": 90,
        "y": 300,
        "wires": [
            [
                "t009"
            ]
        ]
    },
    {
        "id": "t009",
        "type": "function",
        "z": "tournament_flow",
        "name": "Prepare Insert Query",
        "func": "// 文字列値をSQLクエリに安全に埋め込むためのヘルパー関数\nfunction formatSqlString(value) {\n    if (value === null || value === undefined) {\n        return 'NULL';\n    }\n    const strValue = String(value);\n    if (strValue === '') {\n        return \"''\";\n    }\n    const escapedValue = strValue.replace(/'/g, \"''\");\n    return `'${escapedValue}'`;\n}\n\nconst { tournament_id, tournament_nm, start_date, end_date, venue_id, number_coat, remarks } = msg.payload;\n\nif (!tournament_id || !tournament_nm || !start_date || !end_date) {\n    node.warn(\"Missing required fields for insert.\");\n    msg.statusCode = 400;\n    msg.payload = { error: \"tournament_id, tournament_nm, start_date, end_date are required.\" };\n    return [null, msg];\n}\n\n// 日付型はそのままフォーマット\nconst startDateVal = start_date ? `'${start_date}'` : 'NULL';\nconst endDateVal = end_date ? `'${end_date}'` : 'NULL';\n\n// 数値型はnullでない限りそのまま、nullの場合はNULL\nconst numberCoatVal = number_coat !== null ? number_coat : 'NULL';\n\n// 各文字列フィールドをformatSqlString関数で処理\nconst venueIdSql = formatSqlString(venue_id);\nconst remarksSql = formatSqlString(remarks);\n\nmsg.query = `INSERT INTO public.tournament_m (\n    tournament_id, tournament_nm, start_date, end_date, \n    venue_id, number_coat, remarks\n) VALUES (\n    '${tournament_id}', ${formatSqlString(tournament_nm)}, ${startDateVal}, ${endDateVal}, \n    ${venueIdSql}, ${numberCoatVal}, ${remarksSql}\n)`;\n\nreturn [msg, null];",
        "outputs": 2,
        "timeout": "",
        "noerr": 0,
        "initialize": "",
        "finalize": "",
        "libs": [],
        "x": 300,
        "y": 300,
        "wires": [
            [
                "t010"
            ],
            []
        ]
    },
    {
        "id": "t010",
        "type": "postgresql",
        "z": "tournament_flow",
        "name": "Insert Tournament",
        "query": "",
        "postgreSQLConfig": "aab57a20387da7cf",
        "split": false,
        "rowsPerMsg": "",
        "outputs": 1,
        "x": 550,
        "y": 300,
        "wires": [
            [
                "t011"
            ]
        ]
    },
    {
        "id": "t011",
        "type": "function",
        "z": "tournament_flow",
        "name": "Set Success Response",
        "func": "msg.statusCode = 201;\nmsg.payload = { message: \"Tournament created successfully.\" };\nreturn msg;",
        "outputs": 1,
        "timeout": "",
        "noerr": 0,
        "initialize": "",
        "finalize": "",
        "libs": [],
        "x": 770,
        "y": 300,
        "wires": [
            [
                "t999"
            ]
        ]
    },
    {
        "id": "t012",
        "type": "http in",
        "z": "tournament_flow",
        "name": "PUT /tournaments/:tournament_id",
        "url": "/tournaments/:tournament_id",
        "method": "put",
        "upload": false,
        "swaggerDoc": "",
        "x": 140,
        "y": 400,
        "wires": [
            [
                "t013"
            ]
        ]
    },
    {
        "id": "t013",
        "type": "function",
        "z": "tournament_flow",
        "name": "Prepare Update Query",
        "func": "// 文字列値をSQLクエリに安全に埋め込むためのヘルパー関数\nfunction formatSqlString(value) {\n    if (value === null || value === undefined) {\n        return 'NULL';\n    }\n    const strValue = String(value);\n    if (strValue === '') {\n        return \"''\";\n    }\n    const escapedValue = strValue.replace(/'/g, \"''\");\n    return `'${escapedValue}'`;\n}\n\nconst tournamentId = msg.req.params.tournament_id;\nconst { tournament_nm, start_date, end_date, venue_id, number_coat, remarks } = msg.payload;\n\nlet updateFields = [];\n\nif (tournament_nm !== undefined) updateFields.push(`tournament_nm = ${formatSqlString(tournament_nm)}`);\nif (start_date !== undefined) updateFields.push(`start_date = ${start_date ? `'${start_date}'` : 'NULL'}`);\nif (end_date !== undefined) updateFields.push(`end_date = ${end_date ? `'${end_date}'` : 'NULL'}`);\nif (venue_id !== undefined) updateFields.push(`venue_id = ${formatSqlString(venue_id)}`);\nif (number_coat !== undefined) updateFields.push(`number_coat = ${number_coat !== null ? number_coat : 'NULL'}`);\nif (remarks !== undefined) updateFields.push(`remarks = ${formatSqlString(remarks)}`);\n\nif (updateFields.length === 0) {\n    node.warn(\"No fields to update.\");\n    msg.statusCode = 400;\n    msg.payload = { error: \"No fields provided for update.\" };\n    return [null, msg];\n}\n\nmsg.query = `UPDATE public.tournament_m SET ${updateFields.join(', ')} WHERE tournament_id = '${tournamentId}'`;\nreturn [msg, null];",
        "outputs": 2,
        "timeout": "",
        "noerr": 0,
        "initialize": "",
        "finalize": "",
        "libs": [],
        "x": 400,
        "y": 400,
        "wires": [
            [
                "t014"
            ],
            [
                "t999"
            ]
        ]
    },
    {
        "id": "t014",
        "type": "postgresql",
        "z": "tournament_flow",
        "name": "Update Tournament",
        "query": "",
        "postgreSQLConfig": "aab57a20387da7cf",
        "split": false,
        "rowsPerMsg": "",
        "outputs": 1,
        "x": 630,
        "y": 400,
        "wires": [
            [
                "t015"
            ]
        ]
    },
    {
        "id": "t015",
        "type": "function",
        "z": "tournament_flow",
        "name": "Set Update Response",
        "func": "if (msg.payload.rowCount === 0) {\n    msg.statusCode = 404;\n    msg.payload = { error: \"Tournament not found.\" };\n} else {\n    msg.statusCode = 200;\n    msg.payload = { message: \"Tournament updated successfully.\" };\n}\nreturn msg;",
        "outputs": 1,
        "timeout": "",
        "noerr": 0,
        "initialize": "",
        "finalize": "",
        "libs": [],
        "x": 850,
        "y": 400,
        "wires": [
            [
                "t999"
            ]
        ]
    },
    {
        "id": "t016",
        "type": "http in",
        "z": "tournament_flow",
        "name": "DELETE /tournaments/:tournament_id",
        "url": "/tournaments/:tournament_id",
        "method": "delete",
        "upload": false,
        "swaggerDoc": "",
        "x": 150,
        "y": 500,
        "wires": [
            [
                "t017"
            ]
        ]
    },
    {
        "id": "t017",
        "type": "function",
        "z": "tournament_flow",
        "name": "Prepare Delete Query",
        "func": "const tournamentId = msg.req.params.tournament_id;\nif (!tournamentId) {\n    node.warn(\"Missing tournament_id for delete.\");\n    msg.statusCode = 400;\n    msg.payload = { error: \"Tournament ID is required.\" };\n    return [null, msg];\n}\nmsg.query = `DELETE FROM public.tournament_m WHERE tournament_id = '${tournamentId}'`;\nreturn [msg, null];",
        "outputs": 2,
        "timeout": "",
        "noerr": 0,
        "initialize": "",
        "finalize": "",
        "libs": [],
        "x": 420,
        "y": 500,
        "wires": [
            [
                "t018"
            ],
            []
        ]
    },
    {
        "id": "t018",
        "type": "postgresql",
        "z": "tournament_flow",
        "name": "Delete Tournament",
        "query": "",
        "postgreSQLConfig": "aab57a20387da7cf",
        "split": false,
        "rowsPerMsg": "",
        "outputs": 1,
        "x": 630,
        "y": 500,
        "wires": [
            [
                "t019"
            ]
        ]
    },
    {
        "id": "t019",
        "type": "function",
        "z": "tournament_flow",
        "name": "Set Delete Response",
        "func": "if (msg.payload.rowCount === 0) {\n    msg.statusCode = 404;\n    msg.payload = { error: \"Tournament not found.\" };\n} else {\n    msg.statusCode = 204; // No Content for successful delete\n    msg.payload = {};\n}\nreturn msg;",
        "outputs": 1,
        "timeout": "",
        "noerr": 0,
        "initialize": "",
        "finalize": "",
        "libs": [],
        "x": 850,
        "y": 500,
        "wires": [
            [
                "t999"
            ]
        ]
    },
    {
        "id": "t999",
        "type": "http response",
        "z": "tournament_flow",
        "name": "Send Response",
        "statusCode": "200",
        "headers": {
            "Content-Type": "application/json"
        },
        "x": 1120,
        "y": 100,
        "wires": []
    },
    {
        "id": "tc001",
        "type": "http in",
        "z": "tournament_category_flow",
        "name": "GET /tournament_categories/:tournament_id",
        "url": "/tournament_categories/:tournament_id",
        "method": "get",
        "upload": false,
        "swaggerDoc": "",
        "x": 170,
        "y": 100,
        "wires": [
            [
                "tc002"
            ]
        ]
    },
    {
        "id": "tc002",
        "type": "function",
        "z": "tournament_category_flow",
        "name": "Prepare Select Linked Categories Query",
        "func": "const { tournament_id } = msg.req.params;\nif (!tournament_id) {\n    node.warn(\"Missing tournament_id for select.\");\n    msg.statusCode = 400;\n    msg.payload = { error: \"tournament_id is required.\" };\n    return [null, msg];\n}\n// tournament_category_map と category_m を結合してカテゴリー名も取得\nmsg.query = `SELECT tcm.tournament_id, tcm.category_id, cm.category_nm FROM public.tournament_category_map tcm JOIN public.category_m cm ON tcm.category_id = cm.category_id WHERE tcm.tournament_id = '${tournament_id}' ORDER BY tcm.category_id`;\nreturn [msg, null];",
        "outputs": 2,
        "timeout": "",
        "noerr": 0,
        "initialize": "",
        "finalize": "",
        "libs": [],
        "x": 520,
        "y": 100,
        "wires": [
            [
                "tc003"
            ],
            [
                "tc999"
            ]
        ]
    },
    {
        "id": "tc003",
        "type": "postgresql",
        "z": "tournament_category_flow",
        "name": "Select Linked Categories",
        "query": "",
        "postgreSQLConfig": "aab57a20387da7cf",
        "split": false,
        "rowsPerMsg": "",
        "outputs": 1,
        "x": 830,
        "y": 100,
        "wires": [
            [
                "tc999"
            ]
        ]
    },
    {
        "id": "tc004",
        "type": "http in",
        "z": "tournament_category_flow",
        "name": "POST /tournament_categories",
        "url": "/tournament_categories",
        "method": "post",
        "upload": false,
        "swaggerDoc": "",
        "x": 120,
        "y": 200,
        "wires": [
            [
                "tc005"
            ]
        ]
    },
    {
        "id": "tc005",
        "type": "function",
        "z": "tournament_category_flow",
        "name": "Prepare Insert Query",
        "func": "const { tournament_id, category_id } = msg.payload;\nif (!tournament_id || !category_id) {\n    node.warn(\"Missing required fields for insert.\");\n    msg.statusCode = 400;\n    msg.payload = { error: \"tournament_id and category_id are required.\" };\n    return [null, msg];\n}\nmsg.query = `INSERT INTO public.tournament_category_map (tournament_id, category_id) VALUES ('${tournament_id}', '${category_id}')`;\nreturn [msg, null];",
        "outputs": 2,
        "timeout": "",
        "noerr": 0,
        "initialize": "",
        "finalize": "",
        "libs": [],
        "x": 360,
        "y": 200,
        "wires": [
            [
                "tc006"
            ],
            [
                "tc999"
            ]
        ]
    },
    {
        "id": "tc006",
        "type": "postgresql",
        "z": "tournament_category_flow",
        "name": "Insert Tournament Category",
        "query": "",
        "postgreSQLConfig": "aab57a20387da7cf",
        "split": false,
        "rowsPerMsg": "",
        "outputs": 1,
        "x": 620,
        "y": 200,
        "wires": [
            [
                "tc007"
            ]
        ]
    },
    {
        "id": "tc007",
        "type": "function",
        "z": "tournament_category_flow",
        "name": "Set Success Response",
        "func": "msg.statusCode = 201;\nmsg.payload = { message: \"Tournament category added successfully.\" };\nreturn msg;",
        "outputs": 1,
        "timeout": "",
        "noerr": 0,
        "initialize": "",
        "finalize": "",
        "libs": [],
        "x": 870,
        "y": 200,
        "wires": [
            [
                "tc999"
            ]
        ]
    },
    {
        "id": "tc008",
        "type": "http in",
        "z": "tournament_category_flow",
        "name": "DELETE /tournament_categories/:tournament_id/:category_id",
        "url": "/tournament_categories/:tournament_id/:category_id",
        "method": "delete",
        "upload": false,
        "swaggerDoc": "",
        "x": 220,
        "y": 300,
        "wires": [
            [
                "tc009"
            ]
        ]
    },
    {
        "id": "tc009",
        "type": "function",
        "z": "tournament_category_flow",
        "name": "Prepare Delete Query",
        "func": "const { tournament_id, category_id } = msg.req.params;\nif (!tournament_id || !category_id) {\n    node.warn(\"Missing tournament_id or category_id for delete.\");\n    msg.statusCode = 400;\n    msg.payload = { error: \"tournament_id and category_id are required.\" };\n    return [null, msg];\n}\nmsg.query = `DELETE FROM public.tournament_category_map WHERE tournament_id = '${tournament_id}' AND category_id = '${category_id}'`;\nreturn [msg, null];",
        "outputs": 2,
        "timeout": "",
        "noerr": 0,
        "initialize": "",
        "finalize": "",
        "libs": [],
        "x": 560,
        "y": 300,
        "wires": [
            [
                "tc010"
            ],
            [
                "tc999"
            ]
        ]
    },
    {
        "id": "tc010",
        "type": "postgresql",
        "z": "tournament_category_flow",
        "name": "Delete Tournament Category",
        "query": "",
        "postgreSQLConfig": "aab57a20387da7cf",
        "split": false,
        "rowsPerMsg": "",
        "outputs": 1,
        "x": 820,
        "y": 300,
        "wires": [
            [
                "tc011"
            ]
        ]
    },
    {
        "id": "tc011",
        "type": "function",
        "z": "tournament_category_flow",
        "name": "Set Delete Response",
        "func": "if (msg.payload.rowCount === 0) {\n    msg.statusCode = 404;\n    msg.payload = { error: \"Tournament category not found.\" };\n} else {\n    msg.statusCode = 204; // No Content for successful delete\n    msg.payload = {};\n}\nreturn msg;",
        "outputs": 1,
        "timeout": "",
        "noerr": 0,
        "initialize": "",
        "finalize": "",
        "libs": [],
        "x": 1060,
        "y": 300,
        "wires": [
            [
                "tc999"
            ]
        ]
    },
    {
        "id": "tc999",
        "type": "http response",
        "z": "tournament_category_flow",
        "name": "Send Response",
        "statusCode": "200",
        "headers": {
            "Content-Type": "application/json"
        },
        "x": 1260,
        "y": 100,
        "wires": []
    },
    {
        "id": "0b12eae387542859",
        "type": "http in",
        "z": "9d8a9a504f2add4b",
        "name": "GET /tournament-participants",
        "url": "/tournament-participants",
        "method": "get",
        "upload": false,
        "swaggerDoc": "",
        "x": 120,
        "y": 100,
        "wires": [
            [
                "dd2092f956a59f15"
            ]
        ]
    },
    {
        "id": "dd2092f956a59f15",
        "type": "function",
        "z": "9d8a9a504f2add4b",
        "name": "Prepare Select All Query",
        "func": "const tournamentId = msg.req.query.tournament_id;\nconst categoryId = msg.req.query.category_id;\nlet whereClause = 'WHERE 1=1';\n\nif (tournamentId) {\n    whereClause += ` AND tp.tournament_id = '${tournamentId}'`;\n}\nif (categoryId) {\n    whereClause += ` AND tp.category_id = '${categoryId}'`;\n}\n\nmsg.query = `\n    SELECT\n        tp.tournament_id,\n        tm.tournament_nm,\n        tp.player_id,\n        tp.branch_id,\n        bm.branch_nm,\n        pm.familyname,\n        pm.firstname,\n        pm.familyname2,\n        pm.firstname2,\n        pm.sex AS player_sex,\n        pm.birthday AS player_birthday,\n        pm.admissionday,\n        pm.xclass,\n        pm.height AS player_height,\n        pm.weight AS player_weight,\n        tp.category_id,\n        cm.category_nm,\n        tp.entry_date,\n        tp.status\n    FROM\n        public.tournament_participant tp\n    JOIN\n        public.tournament_m tm ON tp.tournament_id = tm.tournament_id\n    JOIN\n        public.category_m cm ON tp.category_id = cm.category_id\n    JOIN\n        public.player_m pm ON tp.player_id = pm.player_id AND tp.branch_id = pm.branch_id\n    JOIN\n        public.branch_m bm ON pm.branch_id = bm.branch_id\n    ${whereClause}\n    ORDER BY\n        tp.tournament_id, tp.category_id, pm.familyname, pm.firstname;\n`;\nreturn msg;",
        "outputs": 1,
        "timeout": "",
        "noerr": 0,
        "initialize": "",
        "finalize": "",
        "libs": [],
        "x": 370,
        "y": 100,
        "wires": [
            [
                "6d829a32872255b1"
            ]
        ]
    },
    {
        "id": "6d829a32872255b1",
        "type": "postgresql",
        "z": "9d8a9a504f2add4b",
        "name": "Select Tournament Participants",
        "query": "",
        "postgreSQLConfig": "aab57a20387da7cf",
        "split": false,
        "rowsPerMsg": "",
        "outputs": 1,
        "x": 630,
        "y": 100,
        "wires": [
            [
                "43ba84aaf050dba7"
            ]
        ]
    },
    {
        "id": "ff510ecf01a4a9b9",
        "type": "http in",
        "z": "9d8a9a504f2add4b",
        "name": "POST /tournament-participants",
        "url": "/tournament-participants",
        "method": "post",
        "upload": false,
        "swaggerDoc": "",
        "x": 130,
        "y": 200,
        "wires": [
            [
                "90c41eaab97229f0"
            ]
        ]
    },
    {
        "id": "90c41eaab97229f0",
        "type": "function",
        "z": "9d8a9a504f2add4b",
        "name": "Prepare Insert Query",
        "func": "const { tournament_id, player_id, branch_id, category_id, status } = msg.payload;\n\nif (!tournament_id || !player_id || !branch_id || !category_id || !status) {\n    node.warn(\"Missing required fields for insert.\");\n    msg.statusCode = 400;\n    msg.payload = { error: \"tournament_id, player_id, branch_id, category_id, status are required.\" };\n    return [null, msg];\n}\n\nmsg.query = `INSERT INTO public.tournament_participant (\n    tournament_id, player_id, branch_id, category_id, status\n) VALUES (\n    '${tournament_id}', '${player_id}', '${branch_id}', '${category_id}', '${status}'\n)`;\nreturn [msg, null];",
        "outputs": 2,
        "timeout": "",
        "noerr": 0,
        "initialize": "",
        "finalize": "",
        "libs": [],
        "x": 380,
        "y": 200,
        "wires": [
            [
                "89d90a14249231ef"
            ],
            [
                "43ba84aaf050dba7"
            ]
        ]
    },
    {
        "id": "89d90a14249231ef",
        "type": "postgresql",
        "z": "9d8a9a504f2add4b",
        "name": "Insert Tournament Participant",
        "query": "",
        "postgreSQLConfig": "aab57a20387da7cf",
        "split": false,
        "rowsPerMsg": "",
        "outputs": 1,
        "x": 640,
        "y": 200,
        "wires": [
            [
                "9309d0f10a50537e"
            ]
        ]
    },
    {
        "id": "9309d0f10a50537e",
        "type": "function",
        "z": "9d8a9a504f2add4b",
        "name": "Set Success Response",
        "func": "msg.statusCode = 201;\nmsg.payload = { message: \"Tournament participant created successfully.\" };\nreturn msg;",
        "outputs": 1,
        "timeout": "",
        "noerr": 0,
        "initialize": "",
        "finalize": "",
        "libs": [],
        "x": 890,
        "y": 200,
        "wires": [
            [
                "43ba84aaf050dba7"
            ]
        ]
    },
    {
        "id": "e2009e9d74409d94",
        "type": "http in",
        "z": "9d8a9a504f2add4b",
        "name": "PUT /tournament-participants/:tid/:pid/:bid/:cid",
        "url": "/tournament-participants/:tid/:pid/:bid/:cid",
        "method": "put",
        "upload": false,
        "swaggerDoc": "",
        "x": 170,
        "y": 300,
        "wires": [
            [
                "5e902363227c5718"
            ]
        ]
    },
    {
        "id": "5e902363227c5718",
        "type": "function",
        "z": "9d8a9a504f2add4b",
        "name": "Prepare Update Query",
        "func": "const { tid, pid, bid, cid } = msg.req.params;\nconst { status } = msg.payload;\n\nif (!status) {\n    node.warn(\"Missing status for update.\");\n    msg.statusCode = 400;\n    msg.payload = { error: \"Status is required for update.\" };\n    return [null, msg];\n}\n\nmsg.query = `UPDATE public.tournament_participant SET status = '${status}' WHERE tournament_id = '${tid}' AND player_id = '${pid}' AND branch_id = '${bid}' AND category_id = '${cid}'`;\nreturn [msg, null];",
        "outputs": 2,
        "timeout": "",
        "noerr": 0,
        "initialize": "",
        "finalize": "",
        "libs": [],
        "x": 460,
        "y": 300,
        "wires": [
            [
                "7cc419f528395dbd"
            ],
            [
                "43ba84aaf050dba7"
            ]
        ]
    },
    {
        "id": "7cc419f528395dbd",
        "type": "postgresql",
        "z": "9d8a9a504f2add4b",
        "name": "Update Tournament Participant",
        "query": "",
        "postgreSQLConfig": "aab57a20387da7cf",
        "split": false,
        "rowsPerMsg": "",
        "outputs": 1,
        "x": 730,
        "y": 300,
        "wires": [
            [
                "ad16158192d8207a"
            ]
        ]
    },
    {
        "id": "ad16158192d8207a",
        "type": "function",
        "z": "9d8a9a504f2add4b",
        "name": "Set Update Response",
        "func": "if (msg.payload.rowCount === 0) {\n    msg.statusCode = 404;\n    msg.payload = { error: \"Tournament participant not found.\" };\n} else {\n    msg.statusCode = 200;\n    msg.payload = { message: \"Tournament participant updated successfully.\" };\n}\nreturn msg;",
        "outputs": 1,
        "timeout": "",
        "noerr": 0,
        "initialize": "",
        "finalize": "",
        "libs": [],
        "x": 980,
        "y": 300,
        "wires": [
            [
                "43ba84aaf050dba7"
            ]
        ]
    },
    {
        "id": "b14c175fe37bdca7",
        "type": "http in",
        "z": "9d8a9a504f2add4b",
        "name": "DELETE /tournament-participants/:tid/:cid/:pid/:bid",
        "url": "/tournament-participants/:tid/:cid/:pid/:bid",
        "method": "delete",
        "upload": false,
        "swaggerDoc": "",
        "x": 180,
        "y": 400,
        "wires": [
            [
                "067c7c34755cfa7f"
            ]
        ]
    },
    {
        "id": "067c7c34755cfa7f",
        "type": "function",
        "z": "9d8a9a504f2add4b",
        "name": "Prepare Delete Query",
        "func": "const { tid, cid, pid, bid } = msg.req.params;\nif (!tid || !cid || !pid || !bid) {\n    node.warn(\"Missing parameters for delete.\");\n    msg.statusCode = 400;\n    msg.payload = { error: \"tournament_id, category_id, player_id, branch_id are required.\" };\n    return [null, msg];\n}\nmsg.query = `DELETE FROM public.tournament_participant WHERE tournament_id = '${tid}' AND category_id = '${cid}' AND player_id = '${pid}' AND branch_id = '${bid}'`;\nreturn [msg, null];",
        "outputs": 2,
        "timeout": "",
        "noerr": 0,
        "initialize": "",
        "finalize": "",
        "libs": [],
        "x": 480,
        "y": 400,
        "wires": [
            [
                "efa25da2a3fb3614"
            ],
            [
                "43ba84aaf050dba7"
            ]
        ]
    },
    {
        "id": "efa25da2a3fb3614",
        "type": "postgresql",
        "z": "9d8a9a504f2add4b",
        "name": "Delete Tournament Participant",
        "query": "",
        "postgreSQLConfig": "aab57a20387da7cf",
        "split": false,
        "rowsPerMsg": "",
        "outputs": 1,
        "x": 750,
        "y": 400,
        "wires": [
            [
                "1bf3e8723b350640"
            ]
        ]
    },
    {
        "id": "1bf3e8723b350640",
        "type": "function",
        "z": "9d8a9a504f2add4b",
        "name": "Set Delete Response",
        "func": "if (msg.payload.rowCount === 0) {\n    msg.statusCode = 404;\n    msg.payload = { error: \"Tournament participant not found.\" };\n} else {\n    msg.statusCode = 204; // No Content for successful delete\n    msg.payload = {};\n}\nreturn msg;",
        "outputs": 1,
        "timeout": "",
        "noerr": 0,
        "initialize": "",
        "finalize": "",
        "libs": [],
        "x": 1000,
        "y": 400,
        "wires": [
            [
                "43ba84aaf050dba7"
            ]
        ]
    },
    {
        "id": "d54a5fa3f01ca3a1",
        "type": "http in",
        "z": "9d8a9a504f2add4b",
        "name": "GET /tournament-participants-detail/:tid/:cid",
        "url": "/tournament-participants-detail/:tid/:cid",
        "method": "get",
        "upload": false,
        "swaggerDoc": "",
        "x": 160,
        "y": 500,
        "wires": [
            [
                "2df5bd029f7d323d"
            ]
        ]
    },
    {
        "id": "2df5bd029f7d323d",
        "type": "function",
        "z": "9d8a9a504f2add4b",
        "name": "Prepare Select Detail Query",
        "func": "const { tid, cid } = msg.req.params;\nif (!tid || !cid) {\n    msg.statusCode = 400;\n    msg.payload = { error: \"Tournament ID and Category ID are required.\" };\n    return [null, msg];\n}\n\nmsg.query = `\n    SELECT\n        tp.tournament_id,\n        tp.player_id,\n        tp.branch_id,\n        tp.category_id,\n        tp.entry_date,\n        tp.status,\n        pm.familyname,\n        pm.firstname,\n        pm.familyname2,\n        pm.firstname2,\n        pm.sex,\n        pm.birthday,\n        pm.admissionday,\n        pm.xclass,\n        pm.height,\n        pm.weight,\n        bm.branch_nm\n    FROM\n        public.tournament_participant tp\n    JOIN\n        public.player_m pm ON tp.player_id = pm.player_id AND tp.branch_id = pm.branch_id\n    JOIN\n        public.branch_m bm ON pm.branch_id = bm.branch_id\n    WHERE\n        tp.tournament_id = '${tid}' AND tp.category_id = '${cid}'\n    ORDER BY\n        pm.familyname, pm.firstname;\n`;\nreturn [msg, null];",
        "outputs": 2,
        "timeout": "",
        "noerr": 0,
        "initialize": "",
        "finalize": "",
        "libs": [],
        "x": 460,
        "y": 500,
        "wires": [
            [
                "8856ce140a4395de"
            ],
            [
                "43ba84aaf050dba7"
            ]
        ]
    },
    {
        "id": "8856ce140a4395de",
        "type": "postgresql",
        "z": "9d8a9a504f2add4b",
        "name": "Select Detail Participants",
        "query": "",
        "postgreSQLConfig": "aab57a20387da7cf",
        "split": false,
        "rowsPerMsg": "",
        "outputs": 1,
        "x": 730,
        "y": 500,
        "wires": [
            [
                "954b23724959d85b"
            ]
        ]
    },
    {
        "id": "954b23724959d85b",
        "type": "function",
        "z": "9d8a9a504f2add4b",
        "name": "Set Response",
        "func": "msg.statusCode = 200;\nmsg.payload = msg.payload;\nreturn msg;",
        "outputs": 1,
        "timeout": "",
        "noerr": 0,
        "initialize": "",
        "finalize": "",
        "libs": [],
        "x": 940,
        "y": 500,
        "wires": [
            [
                "43ba84aaf050dba7"
            ]
        ]
    },
    {
        "id": "43ba84aaf050dba7",
        "type": "http response",
        "z": "9d8a9a504f2add4b",
        "name": "Send Response",
        "statusCode": "200",
        "headers": {
            "Content-Type": "application/json"
        },
        "x": 1100,
        "y": 100,
        "wires": []
    },
    {
        "id": "a1b2c3d4e5f6g7h8",
        "type": "http in",
        "z": "new_flow_tab_id",
        "name": "Save Bracket",
        "url": "/save-bracket",
        "method": "post",
        "upload": false,
        "swaggerDoc": "",
        "x": 70,
        "y": 80,
        "wires": [
            [
                "i9j0k1l2m3n4o5p6"
            ]
        ]
    },
    {
        "id": "i9j0k1l2m3n4o5p6",
        "type": "function",
        "z": "new_flow_tab_id",
        "name": "Prepare SQL Query (UPSERT)",
        "func": "const payload = msg.payload;\nconst {bracket_id, tournament_id, category_id, bracket_data, final_winner_data} = msg.payload;\n\n// SQLインジェクションの脆弱性があるため、入力値のサニタイズを強く推奨します。\n// 特に、bracket_data と final_winner_data はJSON文字列として直接挿入されるため、\n// これらの内容が信頼できるソースからのものであることを確認してください。\n\n// ON CONFLICT (tournament_id, category_id) DO UPDATE を使用し、\n// 該当する組み合わせが存在すれば更新、なければ新規挿入します。\n// bracket_id はPRIMARY KEYなので、INSERT時のみ適用されます。\nmsg.query = `INSERT INTO tournament_brackets (\n    bracket_id,\n    tournament_id,\n    category_id,\n    bracket_data,\n    final_winner_data\n) VALUES (\n    '${bracket_id}', '${tournament_id}', '${category_id}', '${bracket_data}', '${final_winner_data}'\n)\nON CONFLICT (tournament_id, category_id) DO UPDATE SET\n    bracket_data = EXCLUDED.bracket_data,\n    final_winner_data = EXCLUDED.final_winner_data,\n    updated_at = NOW();`;\n\nreturn msg;",
        "outputs": 1,
        "timeout": "",
        "noerr": 0,
        "initialize": "",
        "finalize": "",
        "libs": [],
        "x": 290,
        "y": 80,
        "wires": [
            [
                "q7r8s9t0u1v2w3x4"
            ]
        ]
    },
    {
        "id": "q7r8s9t0u1v2w3x4",
        "type": "postgresql",
        "z": "new_flow_tab_id",
        "name": "PostgreSQL (Save)",
        "query": "",
        "postgreSQLConfig": "aab57a20387da7cf",
        "split": false,
        "rowsPerMsg": "",
        "outputs": 2,
        "x": 530,
        "y": 80,
        "wires": [
            [
                "set_success_response_save"
            ],
            [
                "error_handler_save_function"
            ]
        ]
    },
    {
        "id": "set_success_response_save",
        "type": "function",
        "z": "new_flow_tab_id",
        "name": "Set Success Response",
        "func": "msg.statusCode = 200;\nmsg.payload = { success: true, message: \"トーナメント組み合わせを保存しました！\" };\nreturn msg;",
        "outputs": 1,
        "timeout": "",
        "noerr": 0,
        "initialize": "",
        "finalize": "",
        "libs": [],
        "x": 770,
        "y": 60,
        "wires": [
            [
                "http_response_save_success"
            ]
        ]
    },
    {
        "id": "error_handler_save_function",
        "type": "function",
        "z": "new_flow_tab_id",
        "name": "Set Error Response (Save)",
        "func": "msg.statusCode = 500;\nmsg.payload = {\n    success: false,\n    message: \"保存中にデータベースエラーが発生しました。\",\n    error: msg.error ? msg.error.message : '不明なエラー'\n};\nreturn msg;",
        "outputs": 1,
        "timeout": "",
        "noerr": 0,
        "initialize": "",
        "finalize": "",
        "libs": [],
        "x": 780,
        "y": 100,
        "wires": [
            [
                "http_response_save_error"
            ]
        ]
    },
    {
        "id": "http_response_save_success",
        "type": "http response",
        "z": "new_flow_tab_id",
        "name": "HTTP Response (Save Success)",
        "statusCode": "",
        "headers": {
            "Content-Type": "application/json"
        },
        "x": 1080,
        "y": 60,
        "wires": []
    },
    {
        "id": "http_response_save_error",
        "type": "http response",
        "z": "new_flow_tab_id",
        "name": "HTTP Response (Save Error)",
        "statusCode": "",
        "headers": {
            "Content-Type": "application/json"
        },
        "x": 1060,
        "y": 100,
        "wires": []
    },
    {
        "id": "load_http_in",
        "type": "http in",
        "z": "new_flow_tab_id",
        "name": "Load Bracket",
        "url": "/load-bracket/:tournament_id/:category_id",
        "method": "get",
        "upload": false,
        "swaggerDoc": "",
        "x": 70,
        "y": 200,
        "wires": [
            [
                "load_prepare_sql"
            ]
        ]
    },
    {
        "id": "load_prepare_sql",
        "type": "function",
        "z": "new_flow_tab_id",
        "name": "Prepare Load SQL Query",
        "func": "const tournamentId = msg.req.params.tournament_id;\nconst categoryId = msg.req.params.category_id;\n\n// tournament_idとcategory_idに基づいて最新の組み合わせを取得\n// unique_tournament_category制約があるため、ORDER BYは必須ではないが、\n// 念のためupdated_atでソートして最新のものを取得するロジックにしておく。\nmsg.query = `SELECT bracket_data, final_winner_data FROM tournament_brackets\n             WHERE tournament_id = '${tournamentId}' AND category_id = '${categoryId}'\n             ORDER BY updated_at DESC LIMIT 1;`;\n\n// msg.payload はPostgreSQLノードでパラメータとして使用されないため、ここでは設定しません。\n\nreturn msg;",
        "outputs": 1,
        "timeout": "",
        "noerr": 0,
        "initialize": "",
        "finalize": "",
        "libs": [],
        "x": 270,
        "y": 200,
        "wires": [
            [
                "load_postgresql"
            ]
        ]
    },
    {
        "id": "load_postgresql",
        "type": "postgresql",
        "z": "new_flow_tab_id",
        "name": "PostgreSQL (Load)",
        "query": "",
        "postgreSQLConfig": "aab57a20387da7cf",
        "split": false,
        "rowsPerMsg": "",
        "outputs": 2,
        "x": 490,
        "y": 200,
        "wires": [
            [
                "load_format_response"
            ],
            [
                "error_handler_load_function"
            ]
        ]
    },
    {
        "id": "load_format_response",
        "type": "function",
        "z": "new_flow_tab_id",
        "name": "Format Load Response",
        "func": "if (msg.payload && msg.payload.length > 0) {\n    // データベースから取得したJSONBデータは、Node-REDでは既にJavaScriptオブジェクトとしてパースされているはずです。\n    // しかし、Vue.jsに渡すために再度JSON文字列に変換します。\n    msg.payload = {\n        success: true,\n        bracket_data: JSON.stringify(msg.payload[0].bracket_data),\n        final_winner_data: msg.payload[0].final_winner_data ? JSON.stringify(msg.payload[0].final_winner_data) : null\n    };\n} else {\n    // データが見つからなかった場合\n    msg.statusCode = 404; // Not Found\n    msg.payload = {\n        success: false,\n        message: \"指定された大会とカテゴリーの組み合わせは見つかりませんでした。\"\n    };\n}\nreturn msg;",
        "outputs": 1,
        "timeout": "",
        "noerr": 0,
        "initialize": "",
        "finalize": "",
        "libs": [],
        "x": 730,
        "y": 180,
        "wires": [
            [
                "http_response_load_success"
            ]
        ]
    },
    {
        "id": "error_handler_load_function",
        "type": "function",
        "z": "new_flow_tab_id",
        "name": "Set Error Response (Load)",
        "func": "msg.statusCode = 500;\nmsg.payload = {\n    success: false,\n    message: \"読み込み中にデータベースエラーが発生しました。\",\n    error: msg.error ? msg.error.message : '不明なエラー'\n};\nreturn msg;",
        "outputs": 1,
        "timeout": "",
        "noerr": 0,
        "initialize": "",
        "finalize": "",
        "libs": [],
        "x": 740,
        "y": 220,
        "wires": [
            [
                "http_response_load_error"
            ]
        ]
    },
    {
        "id": "http_response_load_success",
        "type": "http response",
        "z": "new_flow_tab_id",
        "name": "HTTP Response (Load Success)",
        "statusCode": "",
        "headers": {
            "Content-Type": "application/json"
        },
        "x": 1020,
        "y": 180,
        "wires": []
    },
    {
        "id": "http_response_load_error",
        "type": "http response",
        "z": "new_flow_tab_id",
        "name": "HTTP Response (Load Error)",
        "statusCode": "",
        "headers": {
            "Content-Type": "application/json"
        },
        "x": 1000,
        "y": 220,
        "wires": []
    },
    {
        "id": "league_save_http_in",
        "type": "http in",
        "z": "456322a74f8670b8",
        "name": "Save League Bracket",
        "url": "/save-league-bracket",
        "method": "post",
        "upload": false,
        "swaggerDoc": "",
        "x": 100,
        "y": 120,
        "wires": [
            [
                "league_prepare_sql_upsert"
            ]
        ]
    },
    {
        "id": "league_prepare_sql_upsert",
        "type": "function",
        "z": "456322a74f8670b8",
        "name": "Prepare League SQL Query (UPSERT)",
        "func": "const { tournament_id, category_id, league_data, match_results_data, standings_data } = msg.payload;\n\n// 注意: SQLインジェクションの脆弱性があるため、本番環境では必ずプリペアドステートメントを使用してください。\n// Node-REDのPostgreSQLノードがパラメータ化クエリをサポートしている場合は、そちらを使用することを強く推奨します。\n// 特にJSONBデータは、不正な文字列が含まれるとクエリが破損したり、セキュリティリスクにつながる可能性があります。\n\n// JSONBフィールドは、PostgreSQLに渡す前にJSON文字列に変換します。\nconst leagueDataJson = JSON.stringify(league_data);\nconst matchResultsDataJson = JSON.stringify(match_results_data);\nconst standingsDataJson = JSON.stringify(standings_data);\n\nmsg.query = `INSERT INTO public.league_brackets (\n    tournament_id,\n    category_id,\n    league_data,\n    match_results_data,\n    standings_data\n) VALUES (\n    '${tournament_id}', '${category_id}', '${leagueDataJson}'::jsonb, '${matchResultsDataJson}'::jsonb, '${standingsDataJson}'::jsonb\n)\nON CONFLICT (tournament_id, category_id) DO UPDATE SET\n    league_data = EXCLUDED.league_data,\n    match_results_data = EXCLUDED.match_results_data,\n    standings_data = EXCLUDED.standings_data,\n    updated_at = NOW();`;\n\nreturn msg;",
        "outputs": 1,
        "timeout": "",
        "noerr": 0,
        "initialize": "",
        "finalize": "",
        "libs": [],
        "x": 380,
        "y": 120,
        "wires": [
            [
                "league_postgresql_save"
            ]
        ]
    },
    {
        "id": "league_postgresql_save",
        "type": "postgresql",
        "z": "456322a74f8670b8",
        "name": "PostgreSQL (League Save)",
        "query": "",
        "postgreSQLConfig": "aab57a20387da7cf",
        "split": false,
        "rowsPerMsg": "",
        "outputs": 2,
        "x": 680,
        "y": 120,
        "wires": [
            [
                "league_set_success_response_save"
            ],
            [
                "league_error_handler_save_function"
            ]
        ]
    },
    {
        "id": "league_set_success_response_save",
        "type": "function",
        "z": "456322a74f8670b8",
        "name": "Set Success Response",
        "func": "msg.statusCode = 200;\nmsg.payload = { success: true, message: \"リーグ戦データを保存しました！\" };\nreturn msg;",
        "outputs": 1,
        "timeout": "",
        "noerr": 0,
        "initialize": "",
        "finalize": "",
        "libs": [],
        "x": 1000,
        "y": 100,
        "wires": [
            [
                "league_http_response_save_success"
            ]
        ]
    },
    {
        "id": "league_error_handler_save_function",
        "type": "function",
        "z": "456322a74f8670b8",
        "name": "Set Error Response (Save)",
        "func": "msg.statusCode = 500;\nmsg.payload = {\n    success: false,\n    message: \"リーグ戦データの保存中にデータベースエラーが発生しました。\",\n    error: msg.error ? msg.error.message : '不明なエラー'\n};\nreturn msg;",
        "outputs": 1,
        "timeout": "",
        "noerr": 0,
        "initialize": "",
        "finalize": "",
        "libs": [],
        "x": 1010,
        "y": 140,
        "wires": [
            [
                "league_http_response_save_error"
            ]
        ]
    },
    {
        "id": "league_http_response_save_success",
        "type": "http response",
        "z": "456322a74f8670b8",
        "name": "HTTP Response (Save Success)",
        "statusCode": "",
        "headers": {
            "Content-Type": "application/json"
        },
        "x": 1300,
        "y": 100,
        "wires": []
    },
    {
        "id": "league_http_response_save_error",
        "type": "http response",
        "z": "456322a74f8670b8",
        "name": "HTTP Response (Save Error)",
        "statusCode": "",
        "headers": {
            "Content-Type": "application/json"
        },
        "x": 1280,
        "y": 140,
        "wires": []
    },
    {
        "id": "league_load_http_in",
        "type": "http in",
        "z": "456322a74f8670b8",
        "name": "Load League Bracket",
        "url": "/load-league-bracket/:tournament_id/:category_id",
        "method": "get",
        "upload": false,
        "swaggerDoc": "",
        "x": 100,
        "y": 280,
        "wires": [
            [
                "league_prepare_sql_load"
            ]
        ]
    },
    {
        "id": "league_prepare_sql_load",
        "type": "function",
        "z": "456322a74f8670b8",
        "name": "Prepare League Load SQL Query",
        "func": "const tournamentId = msg.req.params.tournament_id;\nconst categoryId = msg.req.params.category_id;\n\n// tournament_idとcategory_idに基づいて最新のリーグ戦データを取得\nmsg.query = `SELECT league_data, match_results_data, standings_data FROM public.league_brackets\n             WHERE tournament_id = '${tournamentId}' AND category_id = '${categoryId}'\n             ORDER BY updated_at DESC LIMIT 1;`;\n\nreturn msg;",
        "outputs": 1,
        "timeout": "",
        "noerr": 0,
        "initialize": "",
        "finalize": "",
        "libs": [],
        "x": 360,
        "y": 280,
        "wires": [
            [
                "league_postgresql_load"
            ]
        ]
    },
    {
        "id": "league_postgresql_load",
        "type": "postgresql",
        "z": "456322a74f8670b8",
        "name": "PostgreSQL (League Load)",
        "query": "",
        "postgreSQLConfig": "aab57a20387da7cf",
        "split": false,
        "rowsPerMsg": "",
        "outputs": 2,
        "x": 640,
        "y": 280,
        "wires": [
            [
                "league_format_load_response"
            ],
            [
                "league_error_handler_load_function"
            ]
        ]
    },
    {
        "id": "league_format_load_response",
        "type": "function",
        "z": "456322a74f8670b8",
        "name": "Format League Load Response",
        "func": "if (msg.payload && msg.payload.length > 0) {\n    // データベースから取得したJSONBデータは、Node-REDでは既にJavaScriptオブジェクトとしてパースされているはずです。\n    // しかし、Vue.jsに渡すために再度JSON文字列に変換します。\n    const data = msg.payload[0];\n    msg.payload = {\n        success: true,\n        league_data: data.league_data,\n        match_results_data: data.match_results_data ? data.match_results_data : null,\n        standings_data: data.standings_data ? data.standings_data : null\n    };\n} else {\n    // データが見つからなかった場合\n    msg.statusCode = 404; // Not Found\n    msg.payload = {\n        success: false,\n        message: \"指定された大会とカテゴリーのリーグ戦データは見つかりませんでした。\"\n    };\n}\nreturn msg;",
        "outputs": 1,
        "timeout": "",
        "noerr": 0,
        "initialize": "",
        "finalize": "",
        "libs": [],
        "x": 1000,
        "y": 260,
        "wires": [
            [
                "league_http_response_load_success"
            ]
        ]
    },
    {
        "id": "league_error_handler_load_function",
        "type": "function",
        "z": "456322a74f8670b8",
        "name": "Set Error Response (Load)",
        "func": "msg.statusCode = 500;\nmsg.payload = {\n    success: false,\n    message: \"リーグ戦データの読み込み中にデータベースエラーが発生しました。\",\n    error: msg.error ? msg.error.message : '不明なエラー'\n};\nreturn msg;",
        "outputs": 1,
        "timeout": "",
        "noerr": 0,
        "initialize": "",
        "finalize": "",
        "libs": [],
        "x": 1010,
        "y": 300,
        "wires": [
            [
                "league_http_response_load_error"
            ]
        ]
    },
    {
        "id": "league_http_response_load_success",
        "type": "http response",
        "z": "456322a74f8670b8",
        "name": "HTTP Response (Load Success)",
        "statusCode": "",
        "headers": {
            "Content-Type": "application/json"
        },
        "x": 1300,
        "y": 260,
        "wires": []
    },
    {
        "id": "league_http_response_load_error",
        "type": "http response",
        "z": "456322a74f8670b8",
        "name": "HTTP Response (Load Error)",
        "statusCode": "",
        "headers": {
            "Content-Type": "application/json"
        },
        "x": 1280,
        "y": 300,
        "wires": []
    },
    {
        "id": "8ff5c0bd3178176b",
        "type": "http in",
        "z": "e1cb6bc6b2821422",
        "name": "GET /load-pentagon-bracket/:tournamentId/:categoryId",
        "url": "/load-pentagon-bracket/:tournamentId/:categoryId",
        "method": "get",
        "upload": false,
        "swaggerDoc": "",
        "x": 220,
        "y": 80,
        "wires": [
            [
                "180b57f41c879e41"
            ]
        ]
    },
    {
        "id": "180b57f41c879e41",
        "type": "function",
        "z": "e1cb6bc6b2821422",
        "name": "パラメータ抽出 & クエリ生成",
        "func": "const tournamentId = msg.req.params.tournamentId;\nconst categoryId = msg.req.params.categoryId;\n\n// SQLインジェクションのリスクを考慮し、必要であればバリデーションを追加してください。\n// ここでは文字列として直接埋め込みます。\nmsg.query = `SELECT\n                        bracket_id,\n                        tournament_id,\n                        category_id,\n                        pentagon_participants_order,\n                        initial_matches,\n                        additional_matches,\n                        standings_data\n                     FROM pentagon_brackets\n                     WHERE tournament_id = '${tournamentId}' AND category_id = '${categoryId}'\n                     ORDER BY updated_at DESC\n                     LIMIT 1;`;\n\nmsg.payload = []; // パラメータを渡さないため空に\n\nreturn msg;",
        "outputs": 1,
        "timeout": "",
        "noerr": 0,
        "initialize": "",
        "finalize": "",
        "libs": [],
        "x": 570,
        "y": 80,
        "wires": [
            [
                "797a8b0652a153e0"
            ]
        ]
    },
    {
        "id": "797a8b0652a153e0",
        "type": "postgresql",
        "z": "e1cb6bc6b2821422",
        "name": "五角形データ取得",
        "query": "msg.query",
        "postgreSQLConfig": "aab57a20387da7cf",
        "split": false,
        "rowsPerMsg": "",
        "outputs": 2,
        "x": 810,
        "y": 80,
        "wires": [
            [
                "113b0658e387a538"
            ],
            [
                "load_error_handler_function"
            ]
        ]
    },
    {
        "id": "113b0658e387a538",
        "type": "function",
        "z": "e1cb6bc6b2821422",
        "name": "データ整形＆JSONBパース",
        "func": "if (msg.payload && msg.payload.length > 0) {\n    const data = msg.payload[0];\n\n    // PostgreSQLノードがJSONBを自動パースするか不明なため、文字列の場合のみJSON.parse()を実行\n    const parseJsonb = (val) => {\n        if (typeof val === 'string') {\n            try { return JSON.parse(val); } catch (e) { return val; }\n        } else {\n            return val; // 既にオブジェクトの場合はそのまま返す\n        }\n    };\n\n    msg.payload = {\n        success: true,\n        pentagon_participants_order: parseJsonb(data.pentagon_participants_order) || [],\n        initial_matches: parseJsonb(data.initial_matches) || [],\n        additional_matches: parseJsonb(data.additional_matches) || [],\n        standings_data: parseJsonb(data.standings_data) || {}\n    };\n} else {\n    // データが見つからなかった場合\n    msg.statusCode = 404;\n    msg.payload = {\n        success: false,\n        message: \"指定された大会とカテゴリーの五角形戦データは見つかりませんでした。\"\n    };\n}\nreturn msg;",
        "outputs": 1,
        "timeout": "",
        "noerr": 0,
        "initialize": "",
        "finalize": "",
        "libs": [],
        "x": 1060,
        "y": 60,
        "wires": [
            [
                "1edba9015c39ddd7"
            ]
        ]
    },
    {
        "id": "1edba9015c39ddd7",
        "type": "http response",
        "z": "e1cb6bc6b2821422",
        "name": "HTTP Response (Load Success)",
        "statusCode": "",
        "headers": {
            "Content-Type": "application/json"
        },
        "x": 1340,
        "y": 60,
        "wires": []
    },
    {
        "id": "load_error_handler_function",
        "type": "function",
        "z": "e1cb6bc6b2821422",
        "name": "Set Error Response (Load)",
        "func": "msg.statusCode = 500;\nmsg.payload = {\n    success: false,\n    message: \"五角形戦データの読み込み中にデータベースエラーが発生しました。\",\n    error: msg.error ? msg.error.message : '不明なエラー'\n};\nreturn msg;",
        "outputs": 1,
        "noerr": 0,
        "initialize": "",
        "finalize": "",
        "libs": [],
        "x": 1060,
        "y": 100,
        "wires": [
            [
                "load_http_response_error"
            ]
        ]
    },
    {
        "id": "load_http_response_error",
        "type": "http response",
        "z": "e1cb6bc6b2821422",
        "name": "HTTP Response (Load Error)",
        "statusCode": "",
        "headers": {
            "Content-Type": "application/json"
        },
        "x": 1320,
        "y": 100,
        "wires": []
    },
    {
        "id": "c8af016d2bbcb453",
        "type": "http in",
        "z": "e1cb6bc6b2821422",
        "name": "POST /save-pentagon-bracket",
        "url": "/save-pentagon-bracket",
        "method": "post",
        "upload": false,
        "swaggerDoc": "",
        "x": 140,
        "y": 260,
        "wires": [
            [
                "7b2cf1d30ed01cc7"
            ]
        ]
    },
    {
        "id": "7b2cf1d30ed01cc7",
        "type": "function",
        "z": "e1cb6bc6b2821422",
        "name": "Prepare Pentagon SQL Query (UPSERT)",
        "func": "const { tournament_id, category_id, pentagon_participants_order, initial_matches, additional_matches, standings_data } = msg.payload;\n\n// 必須データのチェック\nif (!tournament_id || !category_id || !pentagon_participants_order || !initial_matches) {\n    msg.statusCode = 400;\n    msg.payload = {\n        success: false,\n        message: \"必要なデータが不足しています: tournament_id, category_id, pentagon_participants_order, initial_matches は必須です。\"\n    };\n    return msg;\n}\n\n// JSONBフィールドは、PostgreSQLに渡す前にJSON文字列に変換します。\n// SQL文に直接埋め込む形式なので、シングルクォートで囲み、'::jsonb'でキャスト\nconst pentagonParticipantsOrderJson = JSON.stringify(pentagon_participants_order);\nconst initialMatchesJson = JSON.stringify(initial_matches);\nconst additionalMatchesJson = JSON.stringify(additional_matches || []); // なければ空配列\nconst standingsDataJson = JSON.stringify(standings_data || {});     // なければ空オブジェクト\n\nmsg.query = `INSERT INTO pentagon_brackets (\n    tournament_id,\n    category_id,\n    pentagon_participants_order,\n    initial_matches,\n    additional_matches,\n    standings_data\n) VALUES (\n    '${tournament_id}', \n    '${category_id}', \n    '${pentagonParticipantsOrderJson}'::jsonb, \n    '${initialMatchesJson}'::jsonb, \n    '${additionalMatchesJson}'::jsonb, \n    '${standingsDataJson}'::jsonb\n)\nON CONFLICT (tournament_id, category_id) DO UPDATE SET\n    pentagon_participants_order = EXCLUDED.pentagon_participants_order,\n    initial_matches = EXCLUDED.initial_matches,\n    additional_matches = EXCLUDED.additional_matches,\n    standings_data = EXCLUDED.standings_data,\n    updated_at = NOW()\nRETURNING bracket_id;`; // 更新または挿入されたIDを返す\n\nmsg.payload = {}; // パラメータを渡さないため空に\n\nreturn msg;",
        "outputs": 1,
        "timeout": "",
        "noerr": 0,
        "initialize": "",
        "finalize": "",
        "libs": [],
        "x": 440,
        "y": 260,
        "wires": [
            [
                "a4707083a4a54912"
            ]
        ]
    },
    {
        "id": "a4707083a4a54912",
        "type": "postgresql",
        "z": "e1cb6bc6b2821422",
        "name": "五角形データ保存/更新 (UPSERT)",
        "query": "msg.query",
        "postgreSQLConfig": "aab57a20387da7cf",
        "split": false,
        "rowsPerMsg": "",
        "outputs": 2,
        "x": 760,
        "y": 260,
        "wires": [
            [
                "save_set_success_response"
            ],
            [
                "save_error_handler_function"
            ]
        ]
    },
    {
        "id": "save_set_success_response",
        "type": "function",
        "z": "e1cb6bc6b2821422",
        "name": "Set Success Response (Save)",
        "func": "msg.statusCode = 200;\nmsg.payload = { success: true, message: \"五角形戦データを保存しました！\" };\nreturn msg;",
        "outputs": 1,
        "timeout": "",
        "noerr": 0,
        "initialize": "",
        "finalize": "",
        "libs": [],
        "x": 1070,
        "y": 240,
        "wires": [
            [
                "save_http_response_success"
            ]
        ]
    },
    {
        "id": "save_error_handler_function",
        "type": "function",
        "z": "e1cb6bc6b2821422",
        "name": "Set Error Response (Save)",
        "func": "msg.statusCode = 500;\nmsg.payload = {\n    success: false,\n    message: \"五角形戦データの保存中にデータベースエラーが発生しました。\",\n    error: msg.error ? msg.error.message : '不明なエラー'\n};\nreturn msg;",
        "outputs": 1,
        "timeout": "",
        "noerr": 0,
        "initialize": "",
        "finalize": "",
        "libs": [],
        "x": 1060,
        "y": 280,
        "wires": [
            [
                "save_http_response_error"
            ]
        ]
    },
    {
        "id": "save_http_response_success",
        "type": "http response",
        "z": "e1cb6bc6b2821422",
        "name": "HTTP Response (Save Success)",
        "statusCode": "",
        "headers": {
            "Content-Type": "application/json"
        },
        "x": 1360,
        "y": 240,
        "wires": []
    },
    {
        "id": "save_http_response_error",
        "type": "http response",
        "z": "e1cb6bc6b2821422",
        "name": "HTTP Response (Save Error)",
        "statusCode": "",
        "headers": {
            "Content-Type": "application/json"
        },
        "x": 1320,
        "y": 280,
        "wires": []
    },
    {
        "id": "7c1cb5ba30426995",
        "type": "http in",
        "z": "059d960ae3fa1ba9",
        "name": "GET /tournament-all-matches/:tournamentId",
        "url": "/tournament-all-matches/:tournamentId",
        "method": "get",
        "upload": false,
        "swaggerDoc": "",
        "x": 170,
        "y": 80,
        "wires": [
            [
                "f73d0cccac6d9718"
            ]
        ]
    },
    {
        "id": "f73d0cccac6d9718",
        "type": "function",
        "z": "059d960ae3fa1ba9",
        "name": "Prepare Queries & Init Data",
        "func": "const tournamentId = msg.req.params.tournamentId;\n\nif (!tournamentId) {\n    msg.statusCode = 400;\n    msg.payload = { success: false, message: \"Tournament ID is required.\" };\n    return [null, null, null, msg];\n}\n\n// msg に直接必要な情報を設定\nmsg.tournamentId = tournamentId; \n\n// クエリ文字列を msg オブジェクトのプロパティとして設定\nmsg.queryTournament = `SELECT category_id, bracket_data FROM tournament_brackets WHERE tournament_id = '${tournamentId}';`;\n// 修正済み: league_data ではなく match_results_data を取得\nmsg.queryLeague = `SELECT category_id, match_results_data FROM league_brackets WHERE tournament_id = '${tournamentId}';`;\nmsg.queryPentagon = `SELECT category_id, initial_matches, additional_matches FROM pentagon_brackets WHERE tournament_id = '${tournamentId}';`;\n\n// 各出力に、msg.req と msg.res を引き継いだ元のmsgオブジェクトのコピーを渡す\n// それぞれの Postgres ノードに正しいクエリを渡すために msg.query をセット\nconst msgForTournament = { ...msg, query: msg.queryTournament, _dataType: 'tournament' }; // _dataTypeを追加\nconst msgForLeague = { ...msg, query: msg.queryLeague, _dataType: 'league' }; // _dataTypeを追加\nconst msgForPentagon = { ...msg, query: msg.queryPentagon, _dataType: 'pentagon' }; // _dataTypeを追加\n\n// PostgreSQL ノードは msg.query を参照するため、他の queryX プロパティは不要\ndelete msgForTournament.queryLeague;\ndelete msgForTournament.queryPentagon;\ndelete msgForLeague.queryTournament;\ndelete msgForLeague.queryPentagon;\ndelete msgForPentagon.queryTournament;\ndelete msgForPentagon.queryLeague;\n\n// 各出力ポートにメッセージを送信\nreturn [\n    msgForTournament,\n    msgForLeague,\n    msgForPentagon,\n    null\n];",
        "outputs": 4,
        "timeout": "",
        "noerr": 0,
        "initialize": "",
        "finalize": "",
        "libs": [],
        "x": 180,
        "y": 240,
        "wires": [
            [
                "f054a6d0525d0bf0"
            ],
            [
                "b75d0c7b5735e842"
            ],
            [
                "d5b246f2f4d3e8db"
            ],
            [
                "bc5ed929c88932c0"
            ]
        ]
    },
    {
        "id": "f054a6d0525d0bf0",
        "type": "postgresql",
        "z": "059d960ae3fa1ba9",
        "name": "Query Tournament Matches",
        "query": "msg.query",
        "postgreSQLConfig": "aab57a20387da7cf",
        "split": false,
        "rowsPerMsg": "",
        "outputs": 2,
        "x": 540,
        "y": 120,
        "wires": [
            [
                "5f4c7bd5e8d76b68"
            ],
            [
                "bc5ed929c88932c0"
            ]
        ]
    },
    {
        "id": "b75d0c7b5735e842",
        "type": "postgresql",
        "z": "059d960ae3fa1ba9",
        "name": "Query League Matches",
        "query": "msg.query",
        "postgreSQLConfig": "aab57a20387da7cf",
        "split": false,
        "rowsPerMsg": "",
        "outputs": 2,
        "x": 610,
        "y": 200,
        "wires": [
            [
                "90a0bf4ce4615e4d"
            ],
            [
                "bc5ed929c88932c0"
            ]
        ]
    },
    {
        "id": "d5b246f2f4d3e8db",
        "type": "postgresql",
        "z": "059d960ae3fa1ba9",
        "name": "Query Pentagon Matches",
        "query": "msg.query",
        "postgreSQLConfig": "aab57a20387da7cf",
        "split": false,
        "rowsPerMsg": "",
        "outputs": 2,
        "x": 610,
        "y": 340,
        "wires": [
            [
                "3192cdabde3ebb0c"
            ],
            [
                "bc5ed929c88932c0"
            ]
        ]
    },
    {
        "id": "5f4c7bd5e8d76b68",
        "type": "function",
        "z": "059d960ae3fa1ba9",
        "name": "Process Tournament Matches",
        "func": "// Process Tournament Matches\nconst tournamentId = msg.tournamentId;\n\nlet uniqueCategoryIds = new Set();\nlet processedMatches = [];\n\nmsg.payload.forEach(row => {\n    const categoryId = row.category_id;\n    uniqueCategoryIds.add(categoryId);\n    \n    const bracketData = row.bracket_data || []; \n\n    let extractedMatches = [];\n\n    if (Array.isArray(bracketData)) {\n        bracketData.forEach(roundMatches => {\n            if (Array.isArray(roundMatches)) {\n                extractedMatches.push(...roundMatches);\n            }\n        });\n    }\n\n    const matches = extractedMatches.map(m => ({ \n        ...m, \n        matchType: 'tournament', \n        categoryId: categoryId, \n        tournamentId: tournamentId, \n        matchId: m.matchId || `tour-${categoryId}-${m.player1?.player_id || m.player1?.id || 'na'}-${m.player2?.player_id || m.player2?.id || 'na'}-${Math.random().toString(36).substring(2, 8)}`,\n        // ★ここを修正: winner_from_matchXId ではなく winnerOfPlayer1 / winnerOfPlayer2 を使用★\n        winnerOfPlayer1: m.player1?.winnerOf || null, // player1がプレースホルダーの場合にそのIDを格納\n        winnerOfPlayer2: m.player2?.winnerOf || null  // player2がプレースホルダーの場合にそのIDを格納\n    }));\n\n    processedMatches.push(...matches);\n});\n\nmsg.processedMatches = processedMatches;\nmsg.uniqueCategoryIds = Array.from(uniqueCategoryIds);\n\nreturn msg;",
        "outputs": 1,
        "timeout": "",
        "noerr": 0,
        "initialize": "",
        "finalize": "",
        "libs": [],
        "x": 890,
        "y": 80,
        "wires": [
            [
                "NEW_COMBINE_NODE"
            ]
        ]
    },
    {
        "id": "90a0bf4ce4615e4d",
        "type": "function",
        "z": "059d960ae3fa1ba9",
        "name": "Process League Matches",
        "func": "const tournamentId = msg.tournamentId;\n\nlet uniqueCategoryIds = new Set();\nlet processedMatches = [];\n\nmsg.payload.forEach(row => {\n    const categoryId = row.category_id;\n    uniqueCategoryIds.add(categoryId);\n    \n    let leagueMatches = [];\n\n    // row.match_results_data が存在するか確認\n    if (row.match_results_data) {\n        // match_results_data が文字列の場合にJSON.parse()を試す\n        try {\n            // JSON文字列であればパース、そうでなければそのまま使用\n            leagueMatches = typeof row.match_results_data === 'string' \n                            ? JSON.parse(row.match_results_data) \n                            : row.match_results_data;\n            \n            // パース結果が配列でない場合のために、念のため配列であることを確認\n            if (!Array.isArray(leagueMatches)) {\n                leagueMatches = []; // 配列でなければ空の配列とする\n            }\n        } catch (e) {\n            node.warn(`Failed to parse match_results_data for category ${categoryId}: ${e.message}`);\n            leagueMatches = []; // パースエラーの場合も空の配列とする\n        }\n    }\n\n    const matches = leagueMatches.map(m => {\n        const matchId = m.match_id || `league-${categoryId}-${m.player1_id || 'na'}-${m.player2_id || 'na'}`;\n        \n        return { \n            ...m, \n            matchType: 'league', \n            categoryId: categoryId, \n            tournamentId: tournamentId, \n            matchId: matchId,\n            player1: m.player1_data,\n            player2: m.player2_data\n        };\n    });\n\n    processedMatches.push(...matches);\n});\n\nmsg.processedMatches = processedMatches;\nmsg.uniqueCategoryIds = Array.from(uniqueCategoryIds); \n\nreturn msg;",
        "outputs": 1,
        "timeout": "",
        "noerr": 0,
        "initialize": "",
        "finalize": "",
        "libs": [],
        "x": 870,
        "y": 180,
        "wires": [
            [
                "NEW_COMBINE_NODE"
            ]
        ]
    },
    {
        "id": "3192cdabde3ebb0c",
        "type": "function",
        "z": "059d960ae3fa1ba9",
        "name": "Process Pentagon Matches",
        "func": "const tournamentId = msg.tournamentId;\n\nlet uniqueCategoryIds = new Set();\nlet processedMatches = [];\n\nmsg.payload.forEach(row => {\n    const categoryId = row.category_id;\n    uniqueCategoryIds.add(categoryId);\n    \n    const initialMatches = row.initial_matches || [];\n    const additionalMatches = row.additional_matches || [];\n\n    const matches = [\n        ...initialMatches.map(m => ({ ...m, matchType: 'pentagon', categoryId: categoryId, tournamentId: tournamentId, matchId: m.matchId || `pent-${categoryId}-${m.player1?.player_id || 'na'}-${m.player2?.player_id || 'na'}` })),\n        ...additionalMatches.map(m => ({ ...m, matchType: 'pentagon', categoryId: categoryId, tournamentId: tournamentId, matchId: m.matchId || `pent-add-${categoryId}-${m.player1?.player_id || 'na'}-${m.player2?.player_id || 'na'}` }))\n    ];\n\n    processedMatches.push(...matches);\n});\n\nmsg.processedMatches = processedMatches;\nmsg.uniqueCategoryIds = Array.from(uniqueCategoryIds); \n\nreturn msg;",
        "outputs": 1,
        "noerr": 0,
        "initialize": "",
        "finalize": "",
        "libs": [],
        "x": 880,
        "y": 320,
        "wires": [
            [
                "NEW_COMBINE_NODE"
            ]
        ]
    },
    {
        "id": "NEW_COMBINE_NODE",
        "type": "function",
        "z": "059d960ae3fa1ba9",
        "name": "Combine All Matches & Categories",
        "func": "let storedMsgs = flow.get('storedMsgs') || {};\nlet originalReqRes = flow.get('originalReqRes') || null;\n\nconst dataType = msg._dataType;\n\nif (dataType) {\n    storedMsgs[dataType] = msg;\n    flow.set('storedMsgs', storedMsgs);\n}\n\nif (!originalReqRes && msg.req) {\n    originalReqRes = { req: msg.req, res: msg.res, tournamentId: msg.tournamentId };\n    flow.set('originalReqRes', originalReqRes);\n}\n\nconst requiredTypes = ['tournament', 'league', 'pentagon'];\nconst allTypesReceived = requiredTypes.every(type => storedMsgs[type]);\n\nif (allTypesReceived) {\n    let allProcessedMatches = [];\n    let allUniqueCategoryIds = new Set();\n\n    requiredTypes.forEach(type => {\n        const currentMsg = storedMsgs[type];\n        if (currentMsg.processedMatches && Array.isArray(currentMsg.processedMatches)) {\n            allProcessedMatches.push(...currentMsg.processedMatches);\n        }\n        if (currentMsg.uniqueCategoryIds && Array.isArray(currentMsg.uniqueCategoryIds)) {\n            currentMsg.uniqueCategoryIds.forEach(id => allUniqueCategoryIds.add(id));\n        }\n    });\n\n    const outputMsg = { ...originalReqRes };\n    outputMsg.processedMatches = allProcessedMatches;\n    outputMsg.uniqueCategoryIds = Array.from(allUniqueCategoryIds);\n\n    flow.set('storedMsgs', {});\n    flow.set('originalReqRes', null);\n\n    const uniqueCategoryIds = outputMsg.uniqueCategoryIds;\n\n    if (!uniqueCategoryIds || uniqueCategoryIds.length === 0) {\n        // カテゴリが見つからない場合、空の試合データを直接HTTPレスポンスに送信\n        outputMsg.statusCode = 200;\n        outputMsg.payload = { success: true, matches: [] };\n        return [null, outputMsg]; // 出力2へ (HTTP Response (Success))\n    } else {\n        // カテゴリが見つかった場合、カテゴリ名取得クエリを準備\n        const categoryIdList = uniqueCategoryIds.map(id => `'${id}'`).join(',');\n        outputMsg.query = `\n            SELECT\n                tcm.category_id,\n                cm.category_nm as category_name\n            FROM\n                public.tournament_category_map tcm\n            JOIN\n                public.category_m cm ON tcm.category_id = cm.category_id\n            WHERE\n                tcm.category_id IN (${categoryIdList});\n        `;\n        outputMsg.payload = []; // これはPostgreSQLノード用ペイロード\n        return [outputMsg, null]; // 出力1へ (Fetch Category Names)\n    }\n} else {\n    return null; // 全てのメッセージがまだ受信されていない\n}",
        "outputs": 2,
        "timeout": "",
        "noerr": 0,
        "initialize": "flow.set('storedMsgs', {}); flow.set('originalReqRes', null);",
        "finalize": "",
        "libs": [],
        "x": 1220,
        "y": 180,
        "wires": [
            [
                "9332500dc0abf761"
            ],
            [
                "ee4768407247b1a7"
            ]
        ]
    },
    {
        "id": "9332500dc0abf761",
        "type": "postgresql",
        "z": "059d960ae3fa1ba9",
        "name": "Fetch Category Names",
        "query": "msg.query",
        "postgreSQLConfig": "aab57a20387da7cf",
        "split": false,
        "rowsPerMsg": "",
        "outputs": 2,
        "x": 1490,
        "y": 160,
        "wires": [
            [
                "702bb6b4521a7a32"
            ],
            [
                "bc5ed929c88932c0"
            ]
        ]
    },
    {
        "id": "702bb6b4521a7a32",
        "type": "function",
        "z": "059d960ae3fa1ba9",
        "name": "Consolidate & Map Categories",
        "func": "const allCombinedMatches = msg.processedMatches || []; \nconst categoryNames = msg.payload; \n\nconst categoryMap = new Map();\ncategoryNames.forEach(cat => {\n    categoryMap.set(cat.category_id, cat.category_name);\n});\n\nlet finalMatches = [];\nallCombinedMatches.forEach(match => {\n    finalMatches.push({\n        ...match,\n        categoryName: categoryMap.get(match.categoryId) || '不明なカテゴリ'\n    });\n});\n\nmsg.statusCode = 200;\nmsg.payload = { success: true, matches: finalMatches };\nreturn msg;",
        "outputs": 1,
        "timeout": "",
        "noerr": 0,
        "initialize": "",
        "finalize": "",
        "libs": [],
        "x": 1830,
        "y": 180,
        "wires": [
            [
                "ee4768407247b1a7"
            ]
        ]
    },
    {
        "id": "bc5ed929c88932c0",
        "type": "http response",
        "z": "059d960ae3fa1ba9",
        "name": "HTTP Response (Error)",
        "statusCode": "500",
        "headers": {
            "Content-Type": "application/json"
        },
        "x": 1950,
        "y": 360,
        "wires": []
    },
    {
        "id": "ee4768407247b1a7",
        "type": "http response",
        "z": "059d960ae3fa1ba9",
        "name": "HTTP Response (Success)",
        "statusCode": "200",
        "headers": {
            "content-type": "application/json"
        },
        "x": 2080,
        "y": 80,
        "wires": []
    },
    {
        "id": "547140cf2db84662",
        "type": "http in",
        "z": "059d960ae3fa1ba9",
        "name": "DELETE /matches/:tournamentId/:categoryId/:previousCombinationType",
        "url": "/matches/:tournamentId/:categoryId/:previousCombinationType",
        "method": "delete",
        "upload": false,
        "swaggerDoc": "",
        "x": 250,
        "y": 480,
        "wires": [
            [
                "8fcc61db0e4237f7"
            ]
        ]
    },
    {
        "id": "8fcc61db0e4237f7",
        "type": "function",
        "z": "059d960ae3fa1ba9",
        "name": "Prepare Dynamic Delete Query",
        "func": "const tournamentId = msg.req.params.tournamentId;\nconst categoryId = msg.req.params.categoryId;\nconst previousType = msg.req.params.previousCombinationType; // 変更前の形式を受け取る\n\nif (!tournamentId || !categoryId || !previousType) {\n    msg.payload = { success: false, message: \"Tournament ID, Category ID, and Previous Combination Type are required for deletion.\" };\n    node.error(\"Missing parameters for deletion\", msg);\n    return [null, msg]; // エラーパスへ\n}\n\nlet tableName = '';\n// 変更前の形式に基づいて削除対象テーブルを決定\nif (previousType === 'tournament') {\n    tableName = 'tournament_brackets';\n} else if (previousType === 'league') {\n    tableName = 'league_brackets';\n} else if (previousType === 'pentagon') {\n    // 五角形戦のテーブル名が確定したらここに追記\n    // 現時点では不明なので、エラーとするか、何もしないかを決定\n    msg.payload = { success: false, message: `Deletion from '${previousType}_brackets' is not yet supported.` };\n    node.error(\"Unsupported previous combination type for deletion\", msg);\n    return [null, msg]; // エラーパスへ\n} else {\n    msg.payload = { success: false, message: `Unknown previous combination type: ${previousType}` };\n    node.error(\"Unknown previous combination type\", msg);\n    return [null, msg]; // エラーパスへ\n}\n\n// ★ここを修正: msg.query にSQL文字列を直接格納★\n// 重要: この方法はSQLインジェクションのリスクがあります。\n// 信頼できない外部からの入力は直接SQLに埋め込まないよう、ご注意ください。\nmsg.query = `DELETE FROM ${tableName} WHERE tournament_id = '${tournamentId}' AND category_id = '${categoryId}'`;\n\nreturn [msg, null]; // 成功パスへ\n",
        "outputs": 2,
        "timeout": "",
        "noerr": 0,
        "initialize": "",
        "finalize": "",
        "libs": [],
        "x": 670,
        "y": 480,
        "wires": [
            [
                "fa14fa19894b0e2c"
            ],
            [
                "f50ae69ee480bc2e"
            ]
        ]
    },
    {
        "id": "fa14fa19894b0e2c",
        "type": "postgresql",
        "z": "059d960ae3fa1ba9",
        "name": "Execute Dynamic Delete (PostgreSQL)",
        "query": "msg.query",
        "postgreSQLConfig": "aab57a20387da7cf",
        "split": false,
        "rowsPerMsg": "",
        "outputs": 1,
        "x": 970,
        "y": 460,
        "wires": [
            [
                "ba56818e8c842737"
            ]
        ]
    },
    {
        "id": "ba56818e8c842737",
        "type": "function",
        "z": "059d960ae3fa1ba9",
        "name": "Delete Success Response",
        "func": "msg.payload = { success: true, message: \"既存の試合データを削除しました。\" };\nreturn msg;",
        "outputs": 1,
        "timeout": "",
        "noerr": 0,
        "initialize": "",
        "finalize": "",
        "libs": [],
        "x": 1380,
        "y": 460,
        "wires": [
            [
                "50716f5aa5c8d0d6"
            ]
        ]
    },
    {
        "id": "50716f5aa5c8d0d6",
        "type": "http response",
        "z": "059d960ae3fa1ba9",
        "name": "Send Success Response",
        "statusCode": "200",
        "headers": {
            "content-type": "application/json"
        },
        "x": 1750,
        "y": 460,
        "wires": []
    },
    {
        "id": "f50ae69ee480bc2e",
        "type": "http response",
        "z": "059d960ae3fa1ba9",
        "name": "Send Error Response (Bad Request)",
        "statusCode": "400",
        "headers": {
            "content-type": "application/json"
        },
        "x": 1030,
        "y": 520,
        "wires": []
    },
    {
        "id": "a1b2c3d4e5f6a7b8",
        "type": "http in",
        "z": "059d960ae3fa1ba9",
        "name": "GET /combination_data/:tournamentId/:categoryId",
        "url": "/combination_data/:tournamentId/:categoryId",
        "method": "get",
        "upload": false,
        "swaggerDoc": "",
        "x": 180,
        "y": 680,
        "wires": [
            [
                "c1d2e3f4a5b6c7d8"
            ]
        ]
    },
    {
        "id": "c1d2e3f4a5b6c7d8",
        "type": "function",
        "z": "059d960ae3fa1ba9",
        "name": "Prepare Query for Tournament Brackets",
        "func": "const tournamentId = msg.req.params.tournamentId;\nconst categoryId = msg.req.params.categoryId;\n\nif (!tournamentId || !categoryId) {\n    msg.payload = { success: false, message: \"Tournament ID and Category ID are required.\" };\n    node.error(\"Missing parameters for combination data\", msg);\n    return [null]; // エラーパスへ\n}\n\n// tournament_brackets 検索用のSQLをmsg.queryに格納\nmsg.query = `SELECT * FROM tournament_brackets WHERE tournament_id = '${tournamentId}' AND category_id = '${categoryId}'`;\nmsg.searchType = 'tournament'; // 検索タイプを付加\n\nreturn msg;\n",
        "outputs": 1,
        "timeout": "",
        "noerr": 0,
        "initialize": "",
        "finalize": "",
        "libs": [],
        "x": 580,
        "y": 680,
        "wires": [
            [
                "e1f2a3b4c5d6e7f8"
            ]
        ]
    },
    {
        "id": "e1f2a3b4c5d6e7f8",
        "type": "postgresql",
        "z": "059d960ae3fa1ba9",
        "name": "Search Tournament Brackets",
        "query": "msg.query",
        "postgreSQLConfig": "aab57a20387da7cf",
        "split": false,
        "rowsPerMsg": "",
        "outputs": 1,
        "x": 900,
        "y": 680,
        "wires": [
            [
                "g1h2i3j4k5l6m7n8"
            ]
        ]
    },
    {
        "id": "g1h2i3j4k5l6m7n8",
        "type": "function",
        "z": "059d960ae3fa1ba9",
        "name": "Check Tournament Result & Prepare League Query",
        "func": "const tournamentId = msg.req.params.tournamentId;\nconst categoryId = msg.req.params.categoryId;\n\nif (msg.payload && msg.payload.length > 0) {\n    // tournament_brackets にデータがあった場合\n    msg.payload = {\n        success: true,\n        type: msg.searchType, // 'tournament'\n        data: msg.payload[0] // 最初の要素を返す (UNIQUE制約があるので1つのみのはず)\n    };\n    return [msg, null, null]; // 成功パス (1番目の出力) へ\n} else {\n    // tournament_brackets にデータがなかったので、league_brackets を検索\n    msg.query = `SELECT * FROM league_brackets WHERE tournament_id = '${tournamentId}' AND category_id = '${categoryId}'`;\n    msg.searchType = 'league'; // 検索タイプを付加\n    return [null, msg, null]; // league検索パス (2番目の出力) へ\n}\n",
        "outputs": 3,
        "timeout": "",
        "noerr": 0,
        "initialize": "",
        "finalize": "",
        "libs": [],
        "x": 1250,
        "y": 680,
        "wires": [
            [
                "o1p2q3r4s5t6u7v8"
            ],
            [
                "w1x2y3z4a5b6c7d8"
            ],
            []
        ]
    },
    {
        "id": "w1x2y3z4a5b6c7d8",
        "type": "postgresql",
        "z": "059d960ae3fa1ba9",
        "name": "Search League Brackets",
        "query": "msg.query",
        "postgreSQLConfig": "aab57a20387da7cf",
        "split": false,
        "rowsPerMsg": "",
        "outputs": 1,
        "x": 1570,
        "y": 740,
        "wires": [
            [
                "i1j2k3l4m5n6o7p8"
            ]
        ]
    },
    {
        "id": "i1j2k3l4m5n6o7p8",
        "type": "function",
        "z": "059d960ae3fa1ba9",
        "name": "Check League Result & Prepare Pentagon Query",
        "func": "const tournamentId = msg.req.params.tournamentId;\nconst categoryId = msg.req.params.categoryId;\n\nif (msg.payload && msg.payload.length > 0) {\n    // league_brackets にデータがあった場合\n    msg.payload = {\n        success: true,\n        type: msg.searchType, // 'league'\n        data: msg.payload[0]\n    };\n    return [msg, null]; // 成功パス (1番目の出力) へ\n} else {\n    // league_brackets にもデータがなかったので、五角形戦のテーブルを検索\n    // ここに五角形戦のテーブル名とロジックを追記\n    // 現時点では、データなしとして処理します\n    // msg.query = `SELECT * FROM pentagon_brackets WHERE tournament_id = '${tournamentId}' AND category_id = '${categoryId}'`;\n    // msg.searchType = 'pentagon';\n    \n    msg.payload = {\n        success: false,\n        message: \"No combination data found for the given tournament and category.\"\n    };\n    return [null, msg]; // データなしパス (2番目の出力) へ\n}\n",
        "outputs": 2,
        "timeout": "",
        "noerr": 0,
        "initialize": "",
        "finalize": "",
        "libs": [],
        "x": 1890,
        "y": 740,
        "wires": [
            [
                "o1p2q3r4s5t6u7v8"
            ],
            [
                "k1l2m3n4o5p6q7r8"
            ]
        ]
    },
    {
        "id": "o1p2q3r4s5t6u7v8",
        "type": "http response",
        "z": "059d960ae3fa1ba9",
        "name": "Send Combination Data",
        "statusCode": "200",
        "headers": {
            "content-type": "application/json"
        },
        "x": 2230,
        "y": 660,
        "wires": []
    },
    {
        "id": "k1l2m3n4o5p6q7r8",
        "type": "http response",
        "z": "059d960ae3fa1ba9",
        "name": "Send Not Found Response",
        "statusCode": "404",
        "headers": {
            "content-type": "application/json"
        },
        "x": 2240,
        "y": 780,
        "wires": []
    },
    {
        "id": "871af143ba518774",
        "type": "http in",
        "z": "059d960ae3fa1ba9",
        "name": "POST /save-scheduled-matches/:tournamentId",
        "url": "/save-scheduled-matches/:tournamentId",
        "method": "post",
        "upload": false,
        "swaggerDoc": "",
        "x": 180,
        "y": 1020,
        "wires": [
            [
                "i9j8k7l6m5n4o3p2"
            ]
        ]
    },
    {
        "id": "i9j8k7l6m5n4o3p2",
        "type": "function",
        "z": "059d960ae3fa1ba9",
        "name": "Prepare SQL for Save Schedule",
        "func": "// Functionノード: Prepare SQL for Save Schedule\nconst matchesToSave = msg.payload.matches;\nconst tournamentId = msg.req.params.tournamentId;\n\nif (!matchesToSave || !Array.isArray(matchesToSave) || matchesToSave.length === 0) {\n    msg.statusCode = 400;\n    msg.payload = { success: false, message: \"保存する試合データがありません。\" };\n    return msg;\n}\n\nlet valuesClauses = [];\n\nmatchesToSave.forEach(match => {\n    // !! SQLインジェクション対策として、これらの値は必ずエスケープしてください !!\n    // 本番環境では、外部ライブラリの利用や、Node.js pgライブラリの適切なパラメータバインディングを検討してください。\n    // 例として、PostgreSQLのstring_literal_escape関数をFunctionノードのセットアップで定義できる場合:\n    // const escapeSql = (value) => { return flow.get('escapeSql')(value); };\n    // let category_id = match.category_id ? `'${escapeSql(match.category_id)}'` : 'NULL';\n    // 今はエスケープなしで進めますが、この点にご注意ください。\n\n    const category_id = match.category_id ? `'${match.category_id.replace(/'/g, \"''\")}'` : 'NULL'; // 単純なシングルクォートのエスケープ例\n    const match_id = match.match_id ? `'${match.match_id.replace(/'/g, \"''\")}'` : 'NULL';\n    const court = match.court ? `'${match.court.replace(/'/g, \"''\")}'` : 'NULL';\n    const match_order = match.match_order !== null && match.match_order !== undefined ? match.match_order : 'NULL';\n    const scheduled_date = match.scheduled_date ? `'${match.scheduled_date.replace(/'/g, \"''\")}'` : 'NULL';\n    const scheduled_time = match.scheduled_time ? `'${match.scheduled_time.replace(/'/g, \"''\")}'` : 'NULL';\n    const t_id = tournamentId ? `'${tournamentId.replace(/'/g, \"''\")}'` : 'NULL';\n\n    // 各行のVALUES部分を生成\n    const valueRow = `(gen_random_uuid(), ${t_id}, ${category_id}, ${match_id}, ${court}, ${match_order}, ${scheduled_date}, ${scheduled_time}, NOW(), NOW())`;\n    valuesClauses.push(valueRow);\n});\n\n// 全てのVALUES句をカンマで結合\nconst allValues = valuesClauses.join(',\\n');\n\n// 最終的なSQLクエリ文字列を構築\nconst sqlQuery = `\n    INSERT INTO match_schedules (\n        schedule_id, tournament_id, category_id, match_id, court_name, match_order, scheduled_date, scheduled_time, created_at, updated_at\n    ) VALUES \n    ${allValues}\n    ON CONFLICT (tournament_id, category_id, match_id) DO UPDATE SET\n        court_name = EXCLUDED.court_name,\n        match_order = EXCLUDED.match_order,\n        scheduled_date = EXCLUDED.scheduled_date,\n        scheduled_time = EXCLUDED.scheduled_time,\n        updated_at = NOW()\n    RETURNING schedule_id;\n`;\n\n// msg.payload に単一のSQLクエリ文字列を設定\nmsg.payload = sqlQuery; \n\n// PostgreSQLノードが msg.payload を読むように、msg.query も設定しておく（念のため）\n// ただし、通常は msg.payload だけでOKです\nmsg.query = sqlQuery; \n\nreturn msg;",
        "outputs": 1,
        "timeout": "",
        "noerr": 0,
        "initialize": "",
        "finalize": "",
        "libs": [],
        "x": 510,
        "y": 1020,
        "wires": [
            [
                "q3r2s1t0u9v8w7x6"
            ]
        ]
    },
    {
        "id": "q3r2s1t0u9v8w7x6",
        "type": "postgresql",
        "z": "059d960ae3fa1ba9",
        "name": "Save Schedules to DB",
        "query": "msg.query",
        "postgreSQLConfig": "aab57a20387da7cf",
        "split": false,
        "rowsPerMsg": "",
        "outputs": 1,
        "x": 940,
        "y": 1020,
        "wires": [
            [
                "b6881dd9c13f0b11"
            ]
        ]
    },
    {
        "id": "y5z4a3b2c1d0e9f8",
        "type": "http response",
        "z": "059d960ae3fa1ba9",
        "name": "Success Response",
        "statusCode": "200",
        "headers": {
            "Content-Type": "application/json"
        },
        "x": 1520,
        "y": 1020,
        "wires": []
    },
    {
        "id": "b6881dd9c13f0b11",
        "type": "function",
        "z": "059d960ae3fa1ba9",
        "name": "Set statusCode",
        "func": "\nmsg.statusCode = 200; // HTTPステータスコードを200 OKに設定\nmsg.payload = { \n    success: true, \n    message: \"スケジュールが正常に保存されました。\",\n};\n\nreturn msg;",
        "outputs": 1,
        "timeout": 0,
        "noerr": 0,
        "initialize": "",
        "finalize": "",
        "libs": [],
        "x": 1200,
        "y": 1020,
        "wires": [
            [
                "y5z4a3b2c1d0e9f8"
            ]
        ]
    },
    {
        "id": "error_handler_all_matches",
        "type": "catch",
        "z": "059d960ae3fa1ba9",
        "name": "Error Handler",
        "scope": [],
        "uncaught": false,
        "x": 90,
        "y": 1420,
        "wires": [
            [
                "d00ded6ca2276e4e",
                "set_error_response_all_matches"
            ]
        ]
    },
    {
        "id": "set_error_response_all_matches",
        "type": "function",
        "z": "059d960ae3fa1ba9",
        "name": "Set Error Response",
        "func": "msg.statusCode = 500;\nmsg.payload = {\n    success: false,\n    message: \"試合データの取得中にエラーが発生しました。\",\n    error: msg.error ? msg.error.message : '不明なエラー'\n};\nreturn msg;",
        "outputs": 1,
        "timeout": "",
        "noerr": 0,
        "initialize": "",
        "finalize": "",
        "libs": [],
        "x": 450,
        "y": 1420,
        "wires": [
            [
                "http_response_all_matches_error"
            ]
        ]
    },
    {
        "id": "http_response_all_matches_error",
        "type": "http response",
        "z": "059d960ae3fa1ba9",
        "name": "HTTP Response (Error)",
        "statusCode": "",
        "headers": {
            "Content-Type": "application/json"
        },
        "x": 730,
        "y": 1420,
        "wires": []
    },
    {
        "id": "d00ded6ca2276e4e",
        "type": "debug",
        "z": "059d960ae3fa1ba9",
        "name": "Error Debug",
        "active": true,
        "tosidebar": true,
        "console": false,
        "tostatus": false,
        "complete": "true",
        "targetType": "full",
        "statusVal": "",
        "statusType": "auto",
        "x": 250,
        "y": 1480,
        "wires": []
    },
    {
        "id": "new_flow_tab_id_get_all_matches",
        "type": "http in",
        "z": "059d960ae3fa1ba9",
        "name": "Get All Tournament Matches",
        "url": "/api/tournament-matches/:tournament_id",
        "method": "get",
        "upload": false,
        "swaggerDoc": "",
        "x": 120,
        "y": 1320,
        "wires": [
            [
                "cd9815a53a0200ef"
            ]
        ]
    },
    {
        "id": "cd9815a53a0200ef",
        "type": "function",
        "z": "059d960ae3fa1ba9",
        "name": "Prepare Category Query (V2)",
        "func": "const tournamentId = msg.req.params.tournament_id;\nmsg.query = `SELECT tcm.category_id, cm.category_nm \n             FROM public.tournament_category_map tcm \n             JOIN public.category_m cm ON tcm.category_id = cm.category_id \n             WHERE tcm.tournament_id = '${tournamentId}';`;\nmsg.tournamentId = tournamentId; // ★ここで tournamentId を msg に追加\nreturn msg;",
        "outputs": 1,
        "timeout": "",
        "noerr": 0,
        "initialize": "",
        "finalize": "",
        "libs": [],
        "x": 420,
        "y": 1320,
        "wires": [
            [
                "f89cfc0fc340801d"
            ]
        ]
    },
    {
        "id": "f89cfc0fc340801d",
        "type": "postgresql",
        "z": "059d960ae3fa1ba9",
        "name": "Get Categories (V2)",
        "query": "",
        "postgreSQLConfig": "aab57a20387da7cf",
        "split": false,
        "rowsPerMsg": "",
        "outputs": 1,
        "x": 660,
        "y": 1320,
        "wires": [
            [
                "31d7d050ae05b8c9"
            ]
        ]
    },
    {
        "id": "31d7d050ae05b8c9",
        "type": "function",
        "z": "059d960ae3fa1ba9",
        "name": "Prepare All Match Queries (V3)",
        "func": "const categories = msg.payload;\nconst tournamentId = msg.tournamentId; // ★msg から tournamentId を取得\nconst originalReq = msg.req;\nconst originalRes = msg.res;\n\nconst queryMessages = [];\n\nif (categories.length === 0) {\n    msg.payload = { success: true, matches: [] };\n    msg.statusCode = 200;\n    return msg;\n}\n\nflow.set('all_categories_meta', categories);\nflow.set('original_http_req', originalReq);\nflow.set('original_http_res', originalRes);\n\nflow.set('collected_matches', []);\nflow.set('expected_query_count', categories.length * 3);\n\ncategories.forEach(cat => {\n    const categoryId = cat.category_id;\n\n    queryMessages.push({\n        query: `SELECT bracket_data FROM tournament_brackets WHERE tournament_id = '${tournamentId}' AND category_id = '${categoryId}';`,\n        _categoryId: categoryId,\n        _combinationType: 'tournament'\n    });\n\n    queryMessages.push({\n        query: `SELECT match_results_data FROM league_brackets WHERE tournament_id = '${tournamentId}' AND category_id = '${categoryId}';`,\n        _categoryId: categoryId,\n        _combinationType: 'league'\n    });\n\n    queryMessages.push({\n        query: `SELECT initial_matches, additional_matches FROM pentagon_brackets WHERE tournament_id = '${tournamentId}' AND category_id = '${categoryId}';`,\n        _categoryId: categoryId,\n        _combinationType: 'pentagon'\n    });\n});\n\nqueryMessages.forEach(qMsg => {\n    node.send(qMsg);\n});\n\nreturn null;",
        "outputs": 1,
        "timeout": "",
        "noerr": 0,
        "initialize": "",
        "finalize": "",
        "libs": [],
        "x": 910,
        "y": 1320,
        "wires": [
            [
                "abb89e1f00ce78eb"
            ]
        ]
    },
    {
        "id": "abb89e1f00ce78eb",
        "type": "postgresql",
        "z": "059d960ae3fa1ba9",
        "name": "Get Match Data (V3)",
        "query": "",
        "postgreSQLConfig": "aab57a20387da7cf",
        "split": false,
        "rowsPerMsg": "",
        "outputs": 1,
        "x": 1160,
        "y": 1320,
        "wires": [
            [
                "65680c977b54f795"
            ]
        ]
    },
    {
        "id": "65680c977b54f795",
        "type": "function",
        "z": "059d960ae3fa1ba9",
        "name": "Combine Results (V3)",
        "func": "let collectedMatches = flow.get('collected_matches') || [];\nlet expectedCount = flow.get('expected_query_count');\nlet allCategoriesMeta = flow.get('all_categories_meta');\nlet originalReq = flow.get('original_http_req');\nlet originalRes = flow.get('original_http_res');\n\ncollectedMatches.push(msg);\nflow.set('collected_matches', collectedMatches);\n\nexpectedCount--;\nflow.set('expected_query_count', expectedCount);\n\nif (expectedCount === 0) {\n    const allNormalizedMatches = [];\n    const categoriesMap = new Map();\n\n    if (allCategoriesMeta) {\n        allCategoriesMeta.forEach(cat => {\n            categoriesMap.set(cat.category_id, cat.category_nm);\n        });\n    }\n\n    const parseJsonb = (val) => {\n        if (typeof val === 'string') {\n            try { return JSON.parse(val); } catch (e) { return val; }\n        } else {\n            return val;\n        }\n    };\n\n    // BYE選手を判定するヘルパー関数\n    const isPlayerBye = (player) => {\n        // playerがオブジェクトであり、isByeがtrue、またはnameが\"BYE\"の場合にBYEと判定\n        return player && (player.isBye === true || player.name === 'BYE');\n    };\n\n    collectedMatches.forEach(item => {\n        if (item.payload && item.payload.length > 0) {\n            const categoryId = item._categoryId;\n            const combinationType = item._combinationType;\n            const categoryNm = categoriesMap.get(categoryId) || '不明なカテゴリー';\n\n            item.payload.forEach(dbRow => {\n                if (combinationType === 'tournament') {\n                    const bracketData = parseJsonb(dbRow.bracket_data);\n                    if (Array.isArray(bracketData)) {\n                        bracketData.forEach(round => {\n                            if (Array.isArray(round)) {\n                                round.forEach(match => {\n                                    // プレイヤーデータを取得\n                                    const player1Obj = match.player1_data || match.player1;\n                                    const player2Obj = match.player2_data || match.player2;\n\n                                    // BYE試合かどうかを判定\n                                    const isByeMatch = isPlayerBye(player1Obj) || isPlayerBye(player2Obj);\n\n                                    if (!isByeMatch) { // 不戦勝ではない場合のみ追加\n                                        allNormalizedMatches.push({\n                                            matchId: match.match_id || match.matchId,\n                                            player1: player1Obj, // オブジェクトのまま格納\n                                            player2: player2Obj, // オブジェクトのまま格納\n                                            court_id: match.court_id,\n                                            match_order_no: match.match_order_no,\n                                            combination_type: 'トーナメント戦',\n                                            category_id: categoryId,\n                                            category_nm: categoryNm,\n                                        });\n                                    }\n                                });\n                            }\n                        });\n                    }\n                } else if (combinationType === 'league') {\n                    const matchResultsData = parseJsonb(dbRow.match_results_data);\n                    if (Array.isArray(matchResultsData)) {\n                        matchResultsData.forEach(match => {\n                            allNormalizedMatches.push({\n                                matchId: match.match_id || match.matchId,\n                                player1: match.player1_data,\n                                player2: match.player2_data,\n                                court_id: match.court_id,\n                                match_order_no: match.match_order_no,\n                                combination_type: 'リーグ戦',\n                                category_id: categoryId,\n                                category_nm: categoryNm,\n                            });\n                        });\n                    }\n                }\n                else if (combinationType === 'pentagon') {\n                    const initialMatches = parseJsonb(dbRow.initial_matches);\n                    const additionalMatches = parseJsonb(dbRow.additional_matches);\n\n                    if (Array.isArray(initialMatches)) {\n                        initialMatches.forEach(match => {\n                            const player1Obj = match.player1_data || match.player1;\n                            const player2Obj = match.player2_data || match.player2;\n                            const isByeMatch = isPlayerBye(player1Obj) || isPlayerBye(player2Obj);\n\n                            if (!isByeMatch) {\n                                allNormalizedMatches.push({\n                                    matchId: match.match_id || match.matchId,\n                                    player1: player1Obj,\n                                    player2: player2Obj,\n                                    court_id: match.court_id,\n                                    match_order_no: match.match_order_no,\n                                    combination_type: '五角形戦',\n                                    category_id: categoryId,\n                                    category_nm: categoryNm,\n                                });\n                            }\n                        });\n                    }\n                    if (Array.isArray(additionalMatches)) {\n                        additionalMatches.forEach(match => {\n                            const player1Obj = match.player1_data || match.player1;\n                            const player2Obj = match.player2_data || match.player2;\n                            const isByeMatch = isPlayerBye(player1Obj) || isPlayerBye(player2Obj);\n\n                            if (!isByeMatch) {\n                                allNormalizedMatches.push({\n                                    matchId: match.match_id || match.matchId,\n                                    player1: player1Obj,\n                                    player2: player2Obj,\n                                    court_id: match.court_id,\n                                    match_order_no: match.match_order_no,\n                                    combination_type: '五角形戦',\n                                    category_id: categoryId,\n                                    category_nm: categoryNm,\n                                });\n                            }\n                        });\n                    }\n                }\n            });\n        }\n    });\n\n    const responseMsg = {\n        req: originalReq,\n        res: originalRes,\n        statusCode: 200,\n        payload: {\n            success: true,\n            matches: allNormalizedMatches\n        }\n    };\n\n    flow.set('collected_matches', []);\n    flow.set('expected_query_count', 0);\n    flow.set('all_categories_meta', null);\n    flow.set('original_http_req', null);\n    flow.set('original_http_res', null);\n\n    return responseMsg;\n} else {\n    return null;\n}\n",
        "outputs": 1,
        "timeout": "",
        "noerr": 0,
        "initialize": "",
        "finalize": "",
        "libs": [],
        "x": 1380,
        "y": 1320,
        "wires": [
            [
                "81836a068f0ff8d4"
            ]
        ]
    },
    {
        "id": "81836a068f0ff8d4",
        "type": "http response",
        "z": "059d960ae3fa1ba9",
        "name": "HTTP Response (All Matches)",
        "statusCode": "",
        "headers": {
            "Content-Type": "application/json"
        },
        "x": 1630,
        "y": 1320,
        "wires": []
    },
    {
        "id": "4633a0fb7619acd0",
        "type": "http in",
        "z": "5b092667c9e68b9b",
        "name": "POST /save-match-record",
        "url": "/save-match-record",
        "method": "post",
        "upload": false,
        "swaggerDoc": "",
        "x": 110,
        "y": 240,
        "wires": [
            [
                "d6e1f44c8d1b16e8"
            ]
        ]
    },
    {
        "id": "d6e1f44c8d1b16e8",
        "type": "function",
        "z": "5b092667c9e68b9b",
        "name": "Prepare record data for UPSERT",
        "func": "const { record_id, tournament_id, category_id, match_id_in_bracket, match_type, player1_branch_id, player1_id, player2_branch_id, player2_id, winner_player_id, winning_reason, final_score, point_log_json, referee_flags_json, notes } = msg.payload;\n\n// 試合記録の存在チェックとUPSERT用のデータを準備\n// UPSERT (INSERT ON CONFLICT) を使用して、存在すれば更新、なければ新規作成\nmsg.query = `\n    INSERT INTO match_record_t (\n        record_id, tournament_id, category_id, match_id_in_bracket, match_type,\n        player1_branch_id, player1_id, player2_branch_id, player2_id, winner_player_id,\n        winning_reason, final_score, point_log_json, referee_flags_json, notes\n    ) VALUES ($1, $2, $3, $4, $5, $6, $7, $8, $9, $10, $11, $12, $13, $14, $15)\n    ON CONFLICT (record_id) DO UPDATE SET\n        winner_player_id = EXCLUDED.winner_player_id,\n        winning_reason = EXCLUDED.winning_reason,\n        final_score = EXCLUDED.final_score,\n        point_log_json = EXCLUDED.point_log_json,\n        referee_flags_json = EXCLUDED.referee_flags_json,\n        notes = EXCLUDED.notes,\n        updated_at = NOW()\n`;\n\nmsg.payload = [\n    record_id, tournament_id, category_id, match_id_in_bracket, match_type,\n    player1_branch_id, player1_id, player2_branch_id, player2_id, winner_player_id,\n    winning_reason, final_score, JSON.stringify(point_log_json), JSON.stringify(referee_flags_json), notes\n];\n\nreturn msg;\n",
        "outputs": 1,
        "timeout": 0,
        "noerr": 0,
        "initialize": "",
        "finalize": "",
        "libs": [],
        "x": 380,
        "y": 240,
        "wires": [
            [
                "a4c536cf244b975e"
            ]
        ]
    },
    {
        "id": "a4c536cf244b975e",
        "type": "postgresql",
        "z": "5b092667c9e68b9b",
        "name": "Save/Update match record",
        "query": "",
        "postgreSQLConfig": "aab57a20387da7cf",
        "split": false,
        "rowsPerMsg": "",
        "outputs": 1,
        "x": 660,
        "y": 240,
        "wires": [
            [
                "1eed5e9de833cd4d"
            ]
        ]
    },
    {
        "id": "1eed5e9de833cd4d",
        "type": "function",
        "z": "5b092667c9e68b9b",
        "name": "Update bracket SQL",
        "func": "const { tournament_id, category_id, match_id_in_bracket, match_type, winner_player_id, winning_reason } = msg.payload.request;\n\n// PostgreSQLのJSONB関数を使って、組み合わせ表の試合結果を更新するSQLを生成\nlet updateQuery = '';\nlet updateParams = [winner_player_id, winning_reason, tournament_id, category_id];\n\nif (match_type === 'tournament') {\n    updateQuery = `\n        UPDATE tournament_bracket_t\n        SET bracket_data = jsonb_set(\n            bracket_data,\n            (SELECT path FROM tournament_bracket_t, jsonb_array_elements(bracket_data) WITH ORDINALITY arr(elem, idx) WHERE elem->>'match_id' = $3 and tournament_id = $4 and category_id = $5 ORDER BY idx LIMIT 1),\n            jsonb_build_object('winner', jsonb_build_object('player_id', $1, 'winning_reason', $2))\n        )\n        WHERE tournament_id = $4 AND category_id = $5\n    `;\n    updateParams = [winner_player_id, winning_reason, match_id_in_bracket, tournament_id, category_id];\n} else if (match_type === 'league') {\n    // リーグ戦の更新ロジック\n    updateQuery = `\n        UPDATE league_bracket_t\n        SET match_results_data = jsonb_set(\n            match_results_data,\n            (SELECT path FROM league_bracket_t, jsonb_array_elements(match_results_data) WITH ORDINALITY arr(elem, idx) WHERE elem->>'match_id' = $3 and tournament_id = $4 and category_id = $5 ORDER BY idx LIMIT 1),\n            jsonb_build_object('winner', jsonb_build_object('player_id', $1, 'winning_reason', $2))\n        )\n        WHERE tournament_id = $4 AND category_id = $5\n    `;\n    updateParams = [winner_player_id, winning_reason, match_id_in_bracket, tournament_id, category_id];\n} else if (match_type === 'pentagon') {\n    // 五角形戦の更新ロジック\n    updateQuery = `\n        -- initial_matches を更新\n        UPDATE pentagon_bracket_t\n        SET initial_matches = jsonb_set(\n            initial_matches,\n            (SELECT path FROM pentagon_bracket_t, jsonb_array_elements(initial_matches) WITH ORDINALITY arr(elem, idx) WHERE elem->>'match_id' = $3 and tournament_id = $4 and category_id = $5 ORDER BY idx LIMIT 1),\n            jsonb_build_object('winner', jsonb_build_object('player_id', $1, 'winning_reason', $2))\n        )\n        WHERE tournament_id = $4 AND category_id = $5;\n        -- additional_matches を更新\n        UPDATE pentagon_bracket_t\n        SET additional_matches = jsonb_set(\n            additional_matches,\n            (SELECT path FROM pentagon_bracket_t, jsonb_array_elements(additional_matches) WITH ORDINALITY arr(elem, idx) WHERE elem->>'match_id' = $3 and tournament_id = $4 and category_id = $5 ORDER BY idx LIMIT 1),\n            jsonb_build_object('winner', jsonb_build_object('player_id', $1, 'winning_reason', $2))\n        )\n        WHERE tournament_id = $4 AND category_id = $5;\n    `;\n    // UPDATE ... WHERE tournament_id = $4 AND category_id = $5 という構文はPostgreSQLで問題ないが、\n    // 複数のUPDATE文を一つのクエリとして実行する場合は、別途対応が必要になるため、ここでは複数のクエリを生成する前提とする。\n    // 簡略化のため、ここでは1つのクエリを生成している。\n    updateParams = [winner_player_id, winning_reason, match_id_in_bracket, tournament_id, category_id];\n}\n\nmsg.query = updateQuery;\nmsg.payload = updateParams;\n\nreturn msg;\n",
        "outputs": 1,
        "timeout": 0,
        "noerr": 0,
        "initialize": "",
        "finalize": "",
        "libs": [],
        "x": 900,
        "y": 240,
        "wires": [
            [
                "63d6e2fc40e62f6e"
            ]
        ]
    },
    {
        "id": "63d6e2fc40e62f6e",
        "type": "postgresql",
        "z": "5b092667c9e68b9b",
        "name": "Update bracket with result",
        "query": "",
        "postgreSQLConfig": "aab57a20387da7cf",
        "split": false,
        "rowsPerMsg": "",
        "outputs": 1,
        "x": 1130,
        "y": 240,
        "wires": [
            [
                "67ab9e3331fc5ce4"
            ]
        ]
    },
    {
        "id": "67ab9e3331fc5ce4",
        "type": "http response",
        "z": "5b092667c9e68b9b",
        "name": "Send success response",
        "statusCode": "200",
        "headers": {},
        "x": 1390,
        "y": 240,
        "wires": []
    },
    {
        "id": "62168fd336e37179",
        "type": "http in",
        "z": "5b092667c9e68b9b",
        "name": "GET /get-match-details/:tournament_id/:category_id/:court_id/:match_order_no",
        "url": "/get-match-details/:tournament_id/:category_id/:court_id/:match_order_no",
        "method": "get",
        "upload": false,
        "swaggerDoc": "",
        "x": 270,
        "y": 80,
        "wires": [
            [
                "ac99c13d1b39fe8c"
            ]
        ]
    },
    {
        "id": "ac99c13d1b39fe8c",
        "type": "function",
        "z": "5b092667c9e68b9b",
        "name": "Set parameters to msg.params",
        "func": "msg.params = {\n    tournament_id: msg.req.params.tournament_id,\n    category_id: msg.req.params.category_id,\n    court_id: msg.req.params.court_id,\n    match_order_no: parseInt(msg.req.params.match_order_no, 10)\n};\nreturn msg;",
        "outputs": 1,
        "timeout": 0,
        "noerr": 0,
        "initialize": "",
        "finalize": "",
        "libs": [],
        "x": 150,
        "y": 140,
        "wires": [
            [
                "dc2d4cfa6e52178b"
            ]
        ]
    },
    {
        "id": "dc2d4cfa6e52178b",
        "type": "function",
        "z": "5b092667c9e68b9b",
        "name": "Generate SQL for searching matches",
        "func": "const { tournament_id, category_id, court_id, match_order_no } = msg.params;\n\nconst tournamentQuery = `\n    SELECT 'tournament' as match_type, bracket_data AS matches\n    FROM tournament_bracket_t\n    WHERE tournament_id = $1 AND category_id = $2 AND bracket_data::jsonb @> '[{\"court_id\": \"${court_id}\", \"match_order_no\": ${match_order_no}}]'\n`;\n\nconst leagueQuery = `\n    SELECT 'league' as match_type, match_results_data AS matches\n    FROM league_bracket_t\n    WHERE tournament_id = $1 AND category_id = $2 AND match_results_data::jsonb @> '[{\"court_id\": \"${court_id}\", \"match_order_no\": ${match_order_no}}]'\n`;\n\nconst pentagonQuery = `\n    SELECT 'pentagon' as match_type, initial_matches AS matches\n    FROM pentagon_bracket_t\n    WHERE tournament_id = $1 AND category_id = $2 AND initial_matches::jsonb @> '[{\"court_id\": \"${court_id}\", \"match_order_no\": ${match_order_no}}]'\n    UNION ALL\n    SELECT 'pentagon' as match_type, additional_matches AS matches\n    FROM pentagon_bracket_t\n    WHERE tournament_id = $1 AND category_id = $2 AND additional_matches::jsonb @> '[{\"court_id\": \"${court_id}\", \"match_order_no\": ${match_order_no}}]'\n`;\n\nconst query = `\n    ${tournamentQuery}\n    UNION ALL\n    ${leagueQuery}\n    UNION ALL\n    ${pentagonQuery}\n    LIMIT 1;\n`;\n\nmsg.query = query;\nmsg.payload = [tournament_id, category_id];\n\nreturn msg;\n",
        "outputs": 1,
        "timeout": 0,
        "noerr": 0,
        "initialize": "",
        "finalize": "",
        "libs": [],
        "x": 450,
        "y": 140,
        "wires": [
            [
                "340e26a3556b532e"
            ]
        ]
    },
    {
        "id": "340e26a3556b532e",
        "type": "postgresql",
        "z": "5b092667c9e68b9b",
        "name": "Search for match info",
        "query": "",
        "postgreSQLConfig": "aab57a20387da7cf",
        "split": false,
        "rowsPerMsg": "",
        "outputs": 1,
        "x": 720,
        "y": 140,
        "wires": [
            [
                "e6d880b9fcf7b3ce"
            ]
        ]
    },
    {
        "id": "e6d880b9fcf7b3ce",
        "type": "function",
        "z": "5b092667c9e68b9b",
        "name": "Extract match details (JS)",
        "func": "const { court_id, match_order_no } = msg.params;\nconst matches = msg.payload[0].matches;\nconst matchDetails = matches.find(m => m.court_id === court_id && m.match_order_no === match_order_no);\n\nif (!matchDetails) {\n    node.error(`No match found: court_id=${court_id}, match_order_no=${match_order_no}`);\n    return null;\n}\n\nmsg.matchDetails = matchDetails;\nmsg.payload = [msg.payload[0]];\nreturn msg;\n",
        "outputs": 1,
        "timeout": 0,
        "noerr": 0,
        "initialize": "",
        "finalize": "",
        "libs": [],
        "x": 950,
        "y": 140,
        "wires": [
            [
                "476f790390cd0051"
            ]
        ]
    },
    {
        "id": "476f790390cd0051",
        "type": "function",
        "z": "5b092667c9e68b9b",
        "name": "Generate SQL for searching match records",
        "func": "const { tournament_id, category_id } = msg.params;\nconst match_type = msg.payload[0].match_type;\nconst match_in_bracket_data = msg.matchDetails;\n\nconst player1_id = match_in_bracket_data.player1.player_id;\nconst player2_id = match_in_bracket_data.player2.player_id;\nconst sortedIds = [player1_id, player2_id].sort();\nconst match_id_in_bracket = `${sortedIds[0]}-${sortedIds[1]}`;\n\nmsg.query = `SELECT * FROM match_record_t WHERE tournament_id = $1 AND category_id = $2 AND match_id_in_bracket = $3 AND match_type = $4`;\nmsg.payload = [tournament_id, category_id, match_id_in_bracket, match_type];\n\nreturn msg;\n",
        "outputs": 1,
        "timeout": 0,
        "noerr": 0,
        "initialize": "",
        "finalize": "",
        "libs": [],
        "x": 1250,
        "y": 140,
        "wires": [
            [
                "5febebcc877648d9"
            ]
        ]
    },
    {
        "id": "5febebcc877648d9",
        "type": "postgresql",
        "z": "5b092667c9e68b9b",
        "name": "Search for match record",
        "query": "",
        "postgreSQLConfig": "aab57a20387da7cf",
        "split": false,
        "rowsPerMsg": "",
        "outputs": 1,
        "x": 1550,
        "y": 140,
        "wires": [
            [
                "261f5951ba4218ef"
            ]
        ]
    },
    {
        "id": "261f5951ba4218ef",
        "type": "function",
        "z": "5b092667c9e68b9b",
        "name": "Combine player info and match record",
        "func": "const matchDetails = msg.matchDetails;\nconst matchRecord = msg.payload.length > 0 ? msg.payload[0] : null;\n\nconst result = {\n    success: true,\n    match_type: matchDetails.match_type,\n    match_id_in_bracket: matchDetails.match_id,\n    player1: matchDetails.player1,\n    player2: matchDetails.player2,\n    court_id: matchDetails.court_id,\n    match_order_no: matchDetails.match_order_no,\n    record: matchRecord\n};\n\nmsg.payload = result;\nreturn msg;\n",
        "outputs": 1,
        "timeout": 0,
        "noerr": 0,
        "initialize": "",
        "finalize": "",
        "libs": [],
        "x": 1830,
        "y": 140,
        "wires": [
            [
                "09be2aa69517c498"
            ]
        ]
    },
    {
        "id": "09be2aa69517c498",
        "type": "http response",
        "z": "5b092667c9e68b9b",
        "name": "Send response",
        "statusCode": "200",
        "headers": {},
        "x": 2080,
        "y": 140,
        "wires": []
    }
]